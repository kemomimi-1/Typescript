# 泛型 (Generics)

## 概念定义
泛型是 TypeScript 中创建可重用组件的重要特性，它允许我们创建适用于多种类型而不是单一类型的组件。

## 语法示例
```typescript
// 基本泛型函数
function identity<T>(value: T): T {
  return value;
}

// 泛型接口
interface Box<T> {
  value: T;
}

// 泛型类
class Container<T> {
  constructor(public value: T) {}
}

// 使用示例
const num = identity(42); // T 推断为 number
const str = identity("hello"); // T 推断为 string
const box: Box<number> = { value: 100 };
const container = new Container("world");
```

## 使用场景

### 1. 可重用函数
```typescript
// 处理数组的泛型函数
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

function mapArray<T, U>(arr: T[], mapper: (item: T) => U): U[] {
  return arr.map(mapper);
}

// 使用示例
const numbers = [1, 2, 3];
const firstNum = getFirstElement(numbers); // number | undefined
const squared = mapArray(numbers, x => x * x); // number[]
```

### 2. 数据结构
```typescript
// 泛型栈实现
class Stack<T> {
  private items: T[] = [];
  
  push(item: T): void {
    this.items.push(item);
  }
  
  pop(): T | undefined {
    return this.items.pop();
  }
  
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }
}

// 使用示例
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
console.log(numberStack.pop()); // 2

const stringStack = new Stack<string>();
stringStack.push("hello");
stringStack.push("world");
```

### 3. API 响应处理
```typescript
// 泛型 API 响应接口
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

// 用户数据接口
interface User {
  id: number;
  name: string;
  email: string;
}

// 使用示例
async function fetchUser(id: number): Promise<ApiResponse<User>> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// 类型安全的响应处理
const userResponse = await fetchUser(1);
console.log(userResponse.data.name); // 类型安全访问
```

## 泛型约束

### 1. 基本约束
```typescript
// 约束泛型必须具有 length 属性
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(item: T): void {
  console.log(item.length);
}

// 使用示例
logLength("hello"); // 5
logLength([1, 2, 3]); // 3
// logLength(42); // 错误: number 没有 length 属性
```

### 2. keyof 约束
```typescript
// 约束为对象的键
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// 使用示例
const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age"); // number
// const invalid = getProperty(person, "email"); // 错误: "email" 不是 person 的键
```

### 3. 多重约束
```typescript
// 多个接口约束
interface Serializable {
  serialize(): string;
}

interface Identifiable {
  id: number;
}

function processItem<T extends Serializable & Identifiable>(item: T): void {
  console.log(`ID: ${item.id}, Data: ${item.serialize()}`);
}

// 实现类
class User implements Serializable, Identifiable {
  constructor(public id: number, public name: string) {}
  
  serialize(): string {
    return JSON.stringify({ id: this.id, name: this.name });
  }
}

// 使用示例
const user = new User(1, "Alice");
processItem(user);
```

## 高级特性

### 1. 泛型默认值
```typescript
// 泛型参数默认值
interface PaginationParams<T = string> {
  page: number;
  limit: number;
  filter?: T;
}

// 使用默认值
const stringParams: PaginationParams = {
  page: 1,
  limit: 10,
  filter: "active"
};

// 指定类型
const numberParams: PaginationParams<number> = {
  page: 1,
  limit: 10,
  filter: 123
};
```

### 2. 条件类型
```typescript
// 条件类型
type IsString<T> = T extends string ? "yes" : "no";

// 使用示例
type A = IsString<string>; // "yes"
type B = IsString<number>; // "no"

// 提取数组元素类型
type ElementType<T> = T extends (infer U)[] ? U : T;

type NumArray = number[];
type Num = ElementType<NumArray>; // number
type Str = ElementType<string>; // string
```

### 3. 映射类型
```typescript
// 只读版本
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 可选版本
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 使用示例
interface User {
  id: number;
  name: string;
  email: string;
}

type ReadonlyUser = Readonly<User>;
type PartialUser = Partial<User>;

// 创建新用户时可以使用 Partial
function createUser(userData: Partial<User>): User {
  return {
    id: userData.id ?? 0,
    name: userData.name ?? "",
    email: userData.email ?? ""
  };
}
```

## 最佳实践

### 1. 命名约定
```typescript
// 常见的泛型参数命名
// T - Type（类型）
// U - 第二个类型参数
// K - Key（键）
// V - Value（值）
// E - Element（元素）
// R - Return（返回值）

function merge<T, U>(first: T, second: U): T & U {
  return { ...first, ...second };
}
```

### 2. 类型推断
```typescript
// 让 TypeScript 推断类型
function goodExample<T>(value: T): T {
  return value;
}

// 避免不必要的类型注解
const result = goodExample("hello"); // 自动推断为 string

// 只有在必要时才显式指定类型
const explicit = goodExample<string>("hello"); // 显式指定
```

### 3. 错误处理
```typescript
// 泛型错误处理
class Result<T, E = Error> {
  constructor(
    public readonly value?: T,
    public readonly error?: E
  ) {}
  
  isSuccess(): boolean {
    return this.error === undefined;
  }
  
  getValue(): T {
    if (this.error) {
      throw this.error;
    }
    return this.value!;
  }
}

// 使用示例
function tryParseJSON<T>(json: string): Result<T> {
  try {
    const value = JSON.parse(json) as T;
    return new Result(value);
  } catch (error) {
    return new Result(undefined, error);
  }
}
```

## 常见错误

### 1. 过度使用泛型
```typescript
// 不必要的泛型
function unnecessaryGeneric<T>(value: T): T {
  // 如果函数逻辑不依赖 T 的具体类型
  return value;
}

// 简单函数不需要泛型
function simpleIdentity(value: any): any {
  return value;
}
```

### 2. 复杂的类型签名
```typescript
// 过于复杂的类型签名
function tooComplex<
  T extends object,
  K extends keyof T,
  U extends T[K] extends number ? string : number
>(obj: T, key: K): U {
  // 难以理解和维护
  return {} as U;
}

// 简化版本
function simpler<T>(obj: T, key: keyof T): unknown {
  return obj[key];
}
```

### 3. 忽略类型安全
```typescript
// 不安全的类型断言
function unsafeCast<T>(value: any): T {
  return value as T; // 可能不安全
}

// 安全的替代方案
function safeCast<T>(value: unknown): T {
  // 添加类型检查逻辑
  if (typeof value === "object" && value !== null) {
    return value as T;
  }
  throw new Error("Invalid cast");
}
```

## 性能考虑

### 1. 编译时特性
```typescript
// 泛型是编译时特性，不影响运行时性能
function genericFunction<T>(value: T): T {
  return value;
}

// 编译后的代码没有泛型信息
```

### 2. 类型实例化
```typescript
// 每个不同的类型参数都会创建新的类型实例
// 但通常影响很小

// 这些使用相同的编译代码
const a = genericFunction(1);
const b = genericFunction("hello");
const c = genericFunction(true);
```

### 3. 复杂类型检查
```typescript
// 复杂的泛型类型可能增加编译时间
// 但对于大多数应用影响可以忽略

// 简单的泛型几乎不影响性能
function simpleGeneric<T>(value: T): T {
  return value;
}
```

## 总结
泛型是 TypeScript 强大的特性：

✅ **优点**:
- 代码重用性
- 类型安全性
- 更好的抽象能力
- 编译时类型检查

❌ **缺点**:
- 学习曲线较陡
- 复杂的类型签名可能难以理解
- 过度使用可能导致代码难以维护

**最佳实践**:
- 使用有意义的泛型参数命名
- 让 TypeScript 推断类型 when possible
- 使用约束确保类型安全
- 避免过度复杂的泛型类型
- 为复杂的泛型添加文档注释

---
**示例文件**: [examples/27-generics.ts](../examples/27-generics.ts)