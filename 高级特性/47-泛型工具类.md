# 泛型工具类

TypeScript 内置了一系列泛型工具类型（Utility Types），这些是预定义的类型转换器，用于常见类型操作，如使属性可选、挑选子集等。这些工具类型基于映射类型和条件类型构建，帮助开发者避免重复编写 boilerplate 类型代码。

## 为什么使用泛型工具类型？
- **简化类型定义**：快速转换现有类型，而无需手动映射。
- **代码可读性**：使用标准工具类型使代码更易理解。
- **类型安全**：内置工具确保转换正确。

## 常见工具类型及其示例

### Partial<T>
使 T 的所有属性变为可选。

```typescript
type User = { id: number; name: string; email: string };
type PartialUser = Partial<User>; // { id?: number; name?: string; email?: string }

const update: PartialUser = { name: 'Bob' }; // 只更新 name
```

### Required<T>
使 T 的所有属性变为必选（反 Partial）。

```typescript
type OptionalUser = { id?: number; name?: string };
type RequiredUser = Required<OptionalUser>; // { id: number; name: string }
```

### Readonly<T>
使 T 的所有属性变为只读。

```typescript
type ReadonlyUser = Readonly<User>; // { readonly id: number; readonly name: string; readonly email: string }
const user: ReadonlyUser = { id: 1, name: 'Alice', email: 'alice@example.com' };
// user.name = 'Bob'; // 错误：不能修改 readonly 属性
```

### Pick<T, K>
从 T 中挑选指定的键 K 创建新类型。

```typescript
type UserSummary = Pick<User, 'id' | 'name'>; // { id: number; name: string }
```

### Omit<T, K>
从 T 中排除指定的键 K（反 Pick）。

```typescript
type UserWithoutEmail = Omit<User, 'email'>; // { id: number; name: string }
```

### Record<K, T>
创建一个对象类型，键为 K，值为 T。

```typescript
type Status = 'active' | 'inactive';
type UserStatus = Record<Status, number>; // { active: number; inactive: number }
const stats: UserStatus = { active: 10, inactive: 5 };
```

## 高级工具类型
- **ReturnType<T>**：获取函数 T 的返回类型。
  ```typescript
  function getName() { return 'Alice'; }
  type NameType = ReturnType<typeof getName>; // string
  ```
- **Parameters<T>**：获取函数 T 的参数类型元组。
- **Exclude<T, U>** / **Extract<T, U>**：从联合类型中排除/提取部分。

## 注意事项
- **版本依赖**：某些工具类型在 TypeScript 特定版本中引入（如 Omit 在 3.5）。
- **自定义工具类型**：你可以基于映射类型创建自己的工具类型。
- **性能**：在复杂类型中过多嵌套工具类型可能增加编译时间。
- **与条件类型结合**：工具类型常与 `infer` 一起使用以动态推断类型。
- **常见错误**：忘记导入（如在旧版本中），或在非对象类型上使用 Partial 等。

这些工具类型是 TypeScript 开发的利器，能显著减少类型代码量。如果您需要自定义工具类型的示例，请随时告知！