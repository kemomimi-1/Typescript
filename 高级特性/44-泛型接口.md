# 泛型接口

泛型接口是 TypeScript 中一种强大的机制，允许你定义接口时使用类型参数，从而创建可重用的、类型安全的结构。这些参数在接口被使用时指定，类似于函数的泛型。泛型接口特别适用于定义数据结构、API 响应或回调函数等场景。

## 为什么使用泛型接口？
- **重用性**：同一个接口可以处理多种类型，而无需重复代码。
- **类型安全**：确保接口的使用符合预期类型。
- **灵活性**：支持默认类型参数和约束。

## 基本示例：键值对
这是一个简单的泛型接口，用于表示一对值。

```typescript
interface Pair<T, U> {
  first: T;
  second: U;
}

const stringNumberPair: Pair<string, number> = { first: 'hello', second: 42 };
const booleanArrayPair: Pair<boolean, string[]> = { first: true, second: ['a', 'b'] };

// 访问属性时，类型被正确推断
console.log(stringNumberPair.first.toUpperCase()); // 'HELLO'
```

## 函数类型接口
泛型接口常用于定义函数签名。

```typescript
interface Callback<T> {
  (value: T): void;
}

function processCallback<T>(value: T, cb: Callback<T>) {
  cb(value);
}

processCallback('test', (str) => console.log(str.toUpperCase())); // TEST
// processCallback(123, (num) => console.log(num.toUpperCase())); // 错误：number 没有 toUpperCase
```

## 默认类型参数
从 TypeScript 2.3 开始，支持默认类型。

```typescript
interface Box<T = string> {
  content: T;
}

const defaultBox: Box = { content: 'default' }; // T 默认为 string
const numberBox: Box<number> = { content: 100 };
```

## 带约束的泛型接口
可以添加约束来限制类型参数。

```typescript
interface Lengthwise<T extends { length: number }> {
  item: T;
  getLength(): number;
}

class ArrayBox implements Lengthwise<string[]> {
  item: string[];
  constructor(item: string[]) {
    this.item = item;
  }
  getLength() {
    return this.item.length;
  }
}

const box = new ArrayBox(['a', 'b']);
console.log(box.getLength()); // 2
```

## 注意事项
- **接口继承**：泛型接口可以继承其他接口，并传递类型参数。
- **与类型别名比较**：接口更适合可扩展结构，而类型别名更灵活用于联合类型。
- **性能**：泛型接口在大型项目中可能增加类型检查时间，但好处通常超过成本。
- **常见错误**：忘记指定类型参数会导致推断为 any（在 strict 模式下可能报错）。
- **高级用法**：结合映射类型或条件类型创建动态接口。

泛型接口是 TypeScript 类型系统的核心部分，能显著提升代码的可维护性。如果您有特定用例，我可以帮忙扩展示例！