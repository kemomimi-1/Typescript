# 映射类型 (Mapped Types)

## 概念定义
映射类型是 TypeScript 中基于旧类型创建新类型的强大工具，它通过映射现有类型的属性来生成新的类型。

## 语法示例
```typescript
// 基本映射类型语法
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 使用示例
interface User {
  id: number;
  name: string;
  email: string;
}

type ReadonlyUser = Readonly<User>;
type PartialUser = Partial<User>;

// 等效于:
// type ReadonlyUser = {
//   readonly id: number;
//   readonly name: string;
//   readonly email: string;
// };
//
// type PartialUser = {
//   id?: number;
//   name?: string;
//   email?: string;
// };
```

## 基本映射模式

### 1. 只读映射
```typescript
// 创建只读版本
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 使用示例
const user: User = { id: 1, name: "Alice", email: "alice@example.com" };
const readonlyUser: Readonly<User> = user;

// readonlyUser.name = "Bob"; // 错误: 无法分配到 "name"，因为它是只读属性
```

### 2. 可选映射
```typescript
// 创建可选版本
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 使用示例
function updateUser(id: number, updates: Partial<User>): void {
  // 部分更新逻辑
}

updateUser(1, { name: "Bob" }); // 只更新 name
updateUser(1, { email: "bob@example.com" }); // 只更新 email
```

### 3. 必需映射
```typescript
// 创建必需版本（移除可选性）
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 使用示例
interface OptionalUser {
  id?: number;
  name?: string;
  email?: string;
}

type RequiredUser = Required<OptionalUser>;
// 等效于: { id: number; name: string; email: string; }
```

## 高级映射模式

### 1. 键重映射
```typescript
// 使用 as 子句重映射键
type Getters<T> = {
  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];
};

// 使用示例
interface Person {
  name: string;
  age: number;
}

type PersonGetters = Getters<Person>;
// 等效于: {
//   getName: () => string;
//   getAge: () => number;
// }
```

### 2. 条件映射
```typescript
// 基于条件过滤属性
type OnlyStrings<T> = {
  [P in keyof T as T[P] extends string ? P : never]: T[P];
};

// 使用示例
interface MixedProps {
  id: number;
  name: string;
  email: string;
  age: number;
}

type StringProps = OnlyStrings<MixedProps>;
// 等效于: { name: string; email: string; }
```

### 3. 类型转换
```typescript
// 转换属性类型
type ToPromise<T> = {
  [P in keyof T]: Promise<T[P]>;
};

// 使用示例
interface Data {
  user: User;
  settings: Settings;
}

type AsyncData = ToPromise<Data>;
// 等效于: { user: Promise<User>; settings: Promise<Settings>; }
```

## 实用工具类型

### 1. Pick
```typescript
// 选择特定属性
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 使用示例
interface FullUser {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

type BasicUser = Pick<FullUser, "id" | "name" | "email">;
// 只包含 id, name, email
```

### 2. Omit
```typescript
// 排除特定属性
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 使用示例
type UserWithoutDates = Omit<FullUser, "createdAt" | "updatedAt">;
// 排除 createdAt 和 updatedAt
```

### 3. Record
```typescript
// 创建键值对类型
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

// 使用示例
type UserMap = Record<string, User>;
// 等效于: { [key: string]: User; }

const users: UserMap = {
  "user1": { id: 1, name: "Alice", email: "alice@example.com" },
  "user2": { id: 2, name: "Bob", email: "bob@example.com" }
};
```

## 复杂映射场景

### 1. 深度只读
```typescript
// 递归只读映射
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 使用示例
interface NestedData {
  user: {
    id: number;
    profile: {
      name: string;
      avatar: string;
    };
  };
  settings: {
    theme: string;
    notifications: boolean;
  };
}

type ReadonlyNestedData = DeepReadonly<NestedData>;
// 所有层级都是只读的
```

### 2. 条件深度映射
```typescript
// 深度可选，但仅对对象类型
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 使用示例
const partialConfig: DeepPartial<NestedData> = {
  user: {
    profile: {
      name: "Alice" // 只需要提供部分属性
    }
  }
};
```

### 3. 映射联合类型
```typescript
// 映射联合类型中的每个成员
type DistributedMap<T> = T extends any ? { value: T } : never;

// 使用示例
type StringOrNumber = string | number;
type WrappedUnion = DistributedMap<StringOrNumber>;
// 等效于: { value: string } | { value: number }
```

## 模板字面量类型

### 1. 字符串操作
```typescript
// 使用模板字面量类型
type EventName = "click" | "hover" | "focus";
type HandlerName = `on${Capitalize<EventName>}`;
// 等效于: "onClick" | "onHover" | "onFocus"

// 使用示例
interface EventHandlers {
  [K in HandlerName]: () => void;
}

const handlers: EventHandlers = {
  onClick: () => console.log("clicked"),
  onHover: () => console.log("hovered"),
  onFocus: () => console.log("focused")
};
```

### 2. 路径映射
```typescript
// 创建路径类型
type ApiEndpoints = "users" | "posts" | "comments";
type ApiPaths = `/${ApiEndpoints}/${number}`;
// 等效于: "/users/1" | "/posts/1" | "/comments/1"

// 更复杂的路径模式
type ResourcePaths = `/${ApiEndpoints}` | `/${ApiEndpoints}/${number}` | `/${ApiEndpoints}/${number}/comments`;
```

### 3. CSS 类名映射
```typescript
// CSS 类名生成
type Color = "red" | "blue" | "green";
type Size = "sm" | "md" | "lg";
type ButtonClass = `btn-${Color}-${Size}`;
// 等效于: "btn-red-sm" | "btn-red-md" | "btn-red-lg" | "btn-blue-sm" | ...

// 使用示例
const getButtonClass = (color: Color, size: Size): ButtonClass => {
  return `btn-${color}-${size}` as ButtonClass;
};
```

## 最佳实践

### 1. 保持简单
```typescript
// 避免过度复杂的映射类型
// 不良实践
type OverlyComplex<T> = {
  [P in keyof T as T[P] extends string 
    ? `string_${P}` 
    : T[P] extends number 
      ? `number_${P}` 
      : never]: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 良好实践 - 分解复杂逻辑
// 先过滤属性
type Filtered<T> = {
  [P in keyof T as T[P] extends string | number ? P : never]: T[P];
};

// 再转换类型
type Transformed<T> = {
  [P in keyof T]: T[P] extends object ? Partial<T[P]> : T[P];
};
```

### 2. 文档注释
```typescript
// 为复杂的映射类型添加文档
/**
 * 创建一个类型，其中所有属性都是可选的，
 * 并且对于对象属性会递归应用可选性
 */
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * 创建一个类型，其中所有属性都是只读的，
 * 并且对于对象属性会递归应用只读性
 */
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};
```

### 3. 性能考虑
```typescript
// 深度递归类型可能影响编译性能
// 对于大型类型考虑使用非递归版本

// 递归版本
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 非递归版本（仅一层）
type ShallowReadonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

## 常见错误

### 1. 无限递归
```typescript
// 错误的递归定义
type BrokenDeep<T> = {
  [P in keyof T]: BrokenDeep<T[P]>; // 错误: 类型别名循环引用自身
};

// 正确的递归定义
type ProperDeep<T> = {
  [P in keyof T]: T[P] extends object ? ProperDeep<T[P]> : T[P];
};
```

### 2. 错误的键过滤
```typescript
// 错误的过滤逻辑
type WrongFilter<T> = {
  [P in keyof T as T[P] extends string ? P : never]: T[P];
};

// 可能漏掉一些情况
interface Test {
  str: string;
  num: number;
  strOrNum: string | number;
}

type Filtered = WrongFilter<Test>; // 只有 str，漏掉了 strOrNum
```

### 3. 性能问题
```typescript
// 避免在大型类型上使用深度映射
interface VeryLargeType {
  // 数百个属性...
  prop1: string;
  prop2: number;
  // ...
  nested: {
    // 更多嵌套属性...
  };
}

// 可能影响编译性能
type ReadonlyLarge = DeepReadonly<VeryLargeType>;
```

## 总结
映射类型是 TypeScript 的强大功能：

✅ **优点**:
- 类型安全的代码生成
- 减少重复代码
- 更好的类型抽象
- 编译时类型转换

❌ **缺点**:
- 学习曲线较陡
- 复杂类型可能难以理解
- 深度递归可能影响性能

**最佳实践**:
- 从简单映射开始
- 为复杂类型添加文档
- 注意性能影响
- 使用内置工具类型（Pick、Omit、Record等）
- 避免过度复杂的映射逻辑

---
**示例文件**: [examples/28-mapped-types.ts](../examples/28-mapped-types.ts)