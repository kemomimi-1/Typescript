# 映射类型

映射类型（Mapped Types）是 TypeScript 中一种高级类型工具，允许基于现有类型通过遍历其键来创建新类型。这使用 `[P in keyof T]` 语法，类似于 for...in 循环，但应用于类型。映射类型常用于转换属性，如使它们可选或只读。

## 为什么使用映射类型？
- **类型转换**：快速修改现有类型的属性。
- **重用性**：避免手动复制类型定义。
- **动态性**：结合 keyof 和其他操作符创建灵活类型。

## 基本示例
从联合类型创建对象类型。

```typescript
type Keys = 'name' | 'age' | 'city';
type PersonFlags = { [K in Keys]: boolean };
// 等价于 { name: boolean; age: boolean; city: boolean }

const flags: PersonFlags = { name: true, age: false, city: true };
```

## 使用 keyof 操作符
遍历现有类型的键。

```typescript
type User = { id: number; name: string; email: string };

type OptionalUser = { [P in keyof User]?: User[P] };
// 等价于 { id?: number; name?: string; email?: string } （类似于 Partial<User>）
```

## 只读映射
添加 readonly 修饰符。

```typescript
type ReadonlyUser = { readonly [P in keyof User]: User[P] };
// 所有属性变为 readonly
```

## 高级用法：结合 as 条款（TypeScript 4.1+）
重映射键名。

```typescript
type Getters<T> = {
  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];
};

type UserGetters = Getters<User>;
// { getId: () => number; getName: () => string; getEmail: () => string }
```

## 与条件类型结合
动态调整值类型。

```typescript
type Nullable<T> = { [P in keyof T]: T[P] | null };

type NullableUser = Nullable<User>;
// { id: number | null; name: string | null; email: string | null }
```

## 注意事项
- **键类型**：`in` 右侧必须是联合类型（如 string literals 或 keyof）。
- **修饰符**：可以添加/移除 ?（可选）、readonly。
- **性能**：在复杂嵌套中可能增加编译时间。
- **常见错误**：忘记处理泛型参数的约束，导致类型不兼容。
- **内置工具**：许多如 Partial、Record 都是基于映射类型实现的。
- **版本依赖**：as 条款在 4.1+ 可用。

映射类型是 TypeScript 类型体操的基础，能创建高度可定制的类型。如果您需要自定义映射类型的示例，请告诉我！