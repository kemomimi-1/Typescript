# 33. 装饰器 (Decorators)

## 概念定义

**装饰器**是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上。装饰器使用 `@expression` 的形式，其中 `expression` 必须是一个函数，它会在运行时被调用，并接收被装饰的声明信息作为参数。

## 语法示例

### 类装饰器
```typescript
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  greet() {
    return "Hello, " + this.greeting;
  }
}
```

### 方法装饰器
```typescript
function enumerable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.enumerable = value;
  };
}

class Person {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  @enumerable(false)
  greet() {
    return `Hello, ${this.name}`;
  }
}
```

### 属性装饰器
```typescript
function format(formatString: string) {
  return function (target: any, propertyKey: string) {
    // 在元数据中存储格式信息
    Reflect.defineMetadata("format", formatString, target, propertyKey);
  };
}

class Product {
  @format("currency")
  price: number;
  
  constructor(price: number) {
    this.price = price;
  }
}
```

### 参数装饰器
```typescript
function validate() {
  return function (target: any, propertyKey: string, parameterIndex: number) {
    // 添加参数验证逻辑
    const existingValidations = Reflect.getMetadata("validations", target, propertyKey) || [];
    existingValidations.push(parameterIndex);
    Reflect.defineMetadata("validations", existingValidations, target, propertyKey);
  };
}

class Calculator {
  add(@validate() a: number, @validate() b: number): number {
    return a + b;
  }
}
```

## 使用场景

### 1. 日志记录
```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    console.log(`调用方法: ${propertyKey}`);
    console.log(`参数: ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`结果: ${result}`);
    return result;
  };
  
  return descriptor;
}

class Service {
  @log
  processData(data: any) {
    // 数据处理逻辑
    return { processed: true, data };
  }
}
```

### 2. 权限控制
```typescript
function requireRole(role: string) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      // 检查用户权限
      const userRole = "admin"; // 假设从上下文中获取
      if (userRole !== role) {
        throw new Error(`需要 ${role} 权限`);
      }
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class AdminService {
  @requireRole("admin")
  deleteUser(userId: string) {
    // 删除用户逻辑
    return `用户 ${userId} 已删除`;
  }
}
```

### 3. 数据验证
```typescript
function validateEmail(target: any, propertyKey: string) {
  let value: string;
  
  const getter = function () {
    return value;
  };
  
  const setter = function (newVal: string) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(newVal)) {
      throw new Error("无效的邮箱地址");
    }
    value = newVal;
  };
  
  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true
  });
}

class User {
  @validateEmail
  email: string;
  
  constructor(email: string) {
    this.email = email;
  }
}
```

## 注意事项

### 装饰器执行顺序
1. 参数装饰器 → 方法装饰器 → 访问器装饰器 → 属性装饰器 → 类装饰器
2. 同一类型的多个装饰器：从下到上，从右到左执行

### 配置要求
在 `tsconfig.json` 中需要启用装饰器：
```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

### 限制
- 装饰器不能用于函数声明
- 装饰器表达式会在运行时被调用
- 需要理解装饰器的执行时机和上下文

### 最佳实践
```typescript
// 工厂函数模式
function decoratorFactory(config: any) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // 使用配置
    console.log(`装饰器配置: ${JSON.stringify(config)}`);
    return descriptor;
  };
}

class Example {
  @decoratorFactory({ timeout: 1000 })
  method() {
    // 方法实现
  }
}
```

## 示例代码位置

相关示例代码请查看：`examples/33-decorators.ts`

---

**上一节**: [32-声明合并](./32-声明合并.md)  
**下一节**: [34-混入](./34-混入.md)  
**返回目录**: [高级特性目录](../高级特性/)