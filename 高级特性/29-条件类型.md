# 条件类型 (Conditional Types)

## 概念定义
条件类型是 TypeScript 中基于类型关系进行条件判断的类型，它允许我们根据输入类型的不同创建不同的输出类型。

## 语法示例
```typescript
// 基本条件类型语法
type IsString<T> = T extends string ? "yes" : "no";

// 使用示例
type A = IsString<string>; // "yes"
type B = IsString<number>; // "no"
type C = IsString<"hello">; // "yes" (字面量类型也继承自 string)

// 提取数组元素类型
type ElementType<T> = T extends (infer U)[] ? U : T;

type NumArray = number[];
type Num = ElementType<NumArray>; // number
type Str = ElementType<string>; // string
```

## 基本条件类型

### 1. 类型检查
```typescript
// 检查是否为特定类型
type IsNumber<T> = T extends number ? true : false;
type IsArray<T> = T extends any[] ? true : false;
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

// 使用示例
type Test1 = IsNumber<number>; // true
type Test2 = IsNumber<string>; // false
type Test3 = IsArray<number[]>; // true
type Test4 = IsFunction<() => void>; // true
```

### 2. 类型转换
```typescript
// 将类型转换为另一种类型
type ToString<T> = T extends string ? T : string;
type ToArray<T> = T extends any[] ? T : T[];

// 使用示例
type Result1 = ToString<number>; // string
type Result2 = ToString<"hello">; // "hello"
type Result3 = ToArray<number>; // number[]
type Result4 = ToArray<number[]>; // number[]
```

### 3. 默认值处理
```typescript
// 提供类型默认值
type WithDefault<T, Default = never> = T extends never ? Default : T;

// 使用示例
type Result1 = WithDefault<string, number>; // string
type Result2 = WithDefault<never, number>; // number
type Result3 = WithDefault<never>; // never
```

## infer 关键字

### 1. 提取函数返回类型
```typescript
// 提取函数返回类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// 使用示例
type FnReturn = ReturnType<() => number>; // number
type AsyncReturn = ReturnType<() => Promise<string>>; // Promise<string>

function getUser() { return { name: "Alice", age: 30 }; }
type UserReturn = ReturnType<typeof getUser>; // { name: string; age: number }
```

### 2. 提取函数参数类型
```typescript
// 提取函数参数类型
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// 使用示例
type FnParams = Parameters<(x: number, y: string) => void>; // [number, string]
type ConstructorParams = Parameters<new (name: string) => any>; // [string]
```

### 3. 提取构造函数类型
```typescript
// 提取构造函数实例类型
type InstanceType<T> = T extends new (...args: any[]) => infer R ? R : never;

// 使用示例
class User { name: string; }
type UserInstance = InstanceType<typeof User>; // User
type PromiseInstance = InstanceType<PromiseConstructor>; // Promise<any>
```

## 分布式条件类型

### 1. 分布式行为
```typescript
// 条件类型在联合类型上的分布式行为
type Distributed<T> = T extends any ? { value: T } : never;

// 使用示例
type StringOrNumber = string | number;
type WrappedUnion = Distributed<StringOrNumber>;
// 等效于: { value: string } | { value: number }

// 非分布式版本
type NonDistributed<T> = { value: T };
type SimpleWrapped = NonDistributed<StringOrNumber>;
// 等效于: { value: string | number }
```

### 2. 过滤联合类型
```typescript
// 从联合类型中过滤特定类型
type FilterString<T> = T extends string ? T : never;

// 使用示例
type Mixed = string | number | boolean | "literal";
type OnlyStrings = FilterString<Mixed>; // string | "literal"

// 过滤掉特定类型
type ExcludeType<T, U> = T extends U ? never : T;
type WithoutString = ExcludeType<Mixed, string>; // number | boolean
```

### 3. 提取字面量类型
```typescript
// 提取联合类型中的字面量类型
type ExtractLiteral<T> = T extends string | number | boolean ? 
  (string extends T ? never : number extends T ? never : boolean extends T ? never : T) 
  : never;

// 使用示例
type TestUnion = "hello" | "world" | number | boolean;
type LiteralsOnly = ExtractLiteral<TestUnion>; // "hello" | "world"

// 更简单的方法
type SimpleLiteral<T> = T extends string | number | boolean ? 
  (T extends string ? (string extends T ? never : T) : never) 
  : never;
```

## 高级条件类型

### 1. 递归条件类型
```typescript
// 递归展开嵌套数组
type Flatten<T> = T extends any[] ? Flatten<T[number]> : T;

// 使用示例
type Nested = number[][][];
type Flat = Flatten<Nested>; // number

type Complex = [string, number[]][];
type Simplified = Flatten<Complex>; // string | number
```

### 2. 类型谓词
```typescript
// 创建类型谓词
type IsAssignableTo<T, U> = T extends U ? true : false;

// 使用示例
type Test1 = IsAssignableTo<string, string | number>; // true
type Test2 = IsAssignableTo<string, number>; // false
type Test3 = IsAssignableTo<"hello", string>; // true
```

### 3. 条件映射
```typescript
// 基于条件创建映射类型
type ConditionalMap<T> = {
  [K in keyof T]: T[K] extends string ? `str_${K}` : 
                 T[K] extends number ? `num_${K}` : 
                 `other_${K}`;
};

// 使用示例
interface Data {
  name: string;
  age: number;
  active: boolean;
}

type Mapped = ConditionalMap<Data>;
// 等效于: { name: "str_name"; age: "num_age"; active: "other_active"; }
```

## 实用工具类型

### 1. Exclude
```typescript
// 从联合类型中排除某些类型
type Exclude<T, U> = T extends U ? never : T;

// 使用示例
type Numbers = number | string | boolean;
type NoStrings = Exclude<Numbers, string>; // number | boolean
type OnlyNumbers = Exclude<Numbers, string | boolean>; // number
```

### 2. Extract
```typescript
// 从联合类型中提取某些类型
type Extract<T, U> = T extends U ? T : never;

// 使用示例
type Mixed = string | number | boolean;
type StringsOnly = Extract<Mixed, string>; // string
type Primitives = Extract<Mixed, string | number>; // string | number
```

### 3. NonNullable
```typescript
// 移除 null 和 undefined
type NonNullable<T> = T extends null | undefined ? never : T;

// 使用示例
type MaybeString = string | null | undefined;
type DefiniteString = NonNullable<MaybeString>; // string

type Complex = string | number | null;
type Clean = NonNullable<Complex>; // string | number
```

## 复杂条件逻辑

### 1. 多重条件
```typescript
// 多重条件判断
type TypeCategory<T> = 
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends Function ? "function" :
  T extends object ? "object" :
  "other";

// 使用示例
type Cat1 = TypeCategory<string>; // "string"
type Cat2 = TypeCategory<number[]>; // "object"
type Cat3 = TypeCategory<() => void>; // "function"
```

### 2. 类型守卫
```typescript
// 创建复杂的类型守卫
type IsValidConfig<T> = 
  T extends object ?
    "port" extends keyof T ? 
      T["port"] extends number ?
        "host" extends keyof T ?
          T["host"] extends string ? true : false
        : false
      : false
    : false
  : false;

// 使用示例
type Test1 = IsValidConfig<{ port: 3000, host: "localhost" }>; // true
type Test2 = IsValidConfig<{ port: "3000" }>; // false
type Test3 = IsValidConfig<string>; // false
```

### 3. 递归条件解析
```typescript
// 递归解析 Promise 链
type UnwrapPromise<T> = 
  T extends Promise<infer U> ? UnwrapPromise<U> : T;

// 使用示例
type Simple = Promise<string>;
type UnwrappedSimple = UnwrapPromise<Simple>; // string

type Nested = Promise<Promise<Promise<number>>>;
type UnwrappedNested = UnwrapPromise<Nested>; // number

type Mixed = Promise<string | Promise<number>>;
type UnwrappedMixed = UnwrapPromise<Mixed>; // string | number
```

## 最佳实践

### 1. 保持简单
```typescript
// 避免过度复杂的条件类型
// 不良实践
type OverlyComplex<T> = 
  T extends string ? 
    (T extends "hello" ? "greeting" : "string") :
  T extends number ?
    (T extends 0 ? "zero" : 
     T extends 1 ? "one" : "number") :
  "other";

// 良好实践 - 分解逻辑
type StringCategory<T extends string> = 
  T extends "hello" ? "greeting" : "string";

type NumberCategory<T extends number> = 
  T extends 0 ? "zero" : 
  T extends 1 ? "one" : "number";

type SimpleCategory<T> = 
  T extends string ? StringCategory<T> :
  T extends number ? NumberCategory<T> :
  "other";
```

### 2. 使用类型别名
```typescript
// 使用类型别名提高可读性
type StringCondition<T> = T extends string ? T : never;
type NumberCondition<T> = T extends number ? T : never;

type FilterPrimitives<T> = StringCondition<T> | NumberCondition<T>;

// 使用示例
type Mixed = string | number | boolean | object;
type Primitives = FilterPrimitives<Mixed>; // string | number
```

### 3. 注意性能
```typescript
// 深度递归条件类型可能影响编译性能
// 对于大型类型考虑使用迭代方法

// 递归版本
type DeepUnwrap<T> = 
  T extends Promise<infer U> ? DeepUnwrap<U> : T;

// 迭代版本（限制深度）
type UnwrapOnce<T> = T extends Promise<infer U> ? U : T;
type UnwrapTwice<T> = UnwrapOnce<UnwrapOnce<T>>;
type UnwrapThrice<T> = UnwrapOnce<UnwrapTwice<T>>;
```

## 常见错误

### 1. 误用分布式行为
```typescript
// 意外的分布式行为
type Unexpected<T> = T extends any ? T[] : never;

type Test = Unexpected<string | number>; // string[] | number[]
// 可能期望: (string | number)[]

// 正确的做法
type Correct<T> = (T extends any ? T : never)[];
type TestCorrect = Correct<string | number>; // (string | number)[]
```

### 2. 无限递归
```typescript
// 错误的递归定义
type Infinite<T> = T extends any ? Infinite<T> : never; // 错误: 类型别名循环引用

// 正确的递归定义
type ProperRecursive<T> = 
  T extends Promise<infer U> ? ProperRecursive<U> : T;
```

### 3. 过度复杂
```typescript
// 过于复杂的条件逻辑
type TooComplex<T> = 
  T extends string ? 
    (T extends `http${infer Rest}` ? 
      (Rest extends "s" ? "https" : "http") : 
      "other string") :
  T extends number ?
    (T extends 1 | 2 | 3 ? "small" : "large") :
  "other";

// 考虑分解为多个类型
```

## 总结
条件类型是 TypeScript 强大的类型编程工具：

✅ **优点**:
- 强大的类型操作能力
- 基于条件的类型转换
- 分布式类型处理
- 类型安全的抽象

❌ **缺点**:
- 学习曲线较陡
- 复杂类型可能难以理解
- 深度递归可能影响性能

**最佳实践**:
- 从简单条件开始
- 使用类型别名提高可读性
- 注意分布式行为
- 避免过度复杂的逻辑
- 为复杂类型添加文档

---
**示例文件**: [examples/29-conditional-types.ts](../examples/29-conditional-types.ts)