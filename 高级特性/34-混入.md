# 34. 混入 (Mixins)

## 概念定义

**混入**是一种在 TypeScript 中实现多重继承的模式。由于 TypeScript 不支持传统的多重继承，混入提供了一种通过组合方式来复用代码的方法。混入允许你将多个类的功能组合到一个类中。

## 语法示例

### 基础混入模式
```typescript
// 可混入的类
class CanFly {
  fly() {
    console.log("Flying!");
  }
}

class CanSwim {
  swim() {
    console.log("Swimming!");
  }
}

// 混入函数
function applyMixins(derivedCtor: any, baseCtors: any[]) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      if (name !== "constructor") {
        derivedCtor.prototype[name] = baseCtor.prototype[name];
      }
    });
  });
}

// 目标类
class SuperCreature {
  // 空类，等待混入
}

// 应用混入
applyMixins(SuperCreature, [CanFly, CanSwim]);

// 使用混入后的类
const creature = new SuperCreature() as SuperCreature & CanFly & CanSwim;
creature.fly();    // Flying!
creature.swim();   // Swimming!
```

### 使用接口声明混入
```typescript
// 定义混入接口
interface CanSing {
  sing(): void;
}

interface CanDance {
  dance(): void;
}

// 实现混入类
class Singer implements CanSing {
  sing() {
    console.log("La la la!");
  }
}

class Dancer implements CanDance {
  dance() {
    console.log("Dancing!");
  }
}

// 目标类
class Performer {
  // 空类
}

// 应用混入
interface Performer extends CanSing, CanDance {}
applyMixins(Performer, [Singer, Dancer]);

// 使用
const performer = new Performer() as Performer & CanSing & CanDance;
performer.sing();  // La la la!
performer.dance(); // Dancing!
```

### 构造函数混入
```typescript
// 混入函数（支持构造函数）
function mixin(...mixins: any[]) {
  return function (target: any) {
    mixins.forEach(mixin => {
      Object.getOwnPropertyNames(mixin.prototype).forEach(name => {
        if (name !== "constructor") {
          target.prototype[name] = mixin.prototype[name];
        }
      });
    });
  };
}

// 混入类
class Logger {
  log(message: string) {
    console.log(`[LOG] ${new Date().toISOString()}: ${message}`);
  }
}

class Timestamp {
  getTimestamp() {
    return new Date().toISOString();
  }
}

// 应用混入
@mixin(Logger, Timestamp)
class Service {
  execute() {
    (this as any).log("Service executed");
    console.log((this as any).getTimestamp());
  }
}

const service = new Service();
service.execute();
```

## 使用场景

### 1. 功能组合
```typescript
// 可复用的功能模块
class Validation {
  validateEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
  
  validatePhone(phone: string): boolean {
    return /^1[3-9]\d{9}$/.test(phone);
  }
}

class Formatting {
  formatCurrency(amount: number): string {
    return `$${amount.toFixed(2)}`;
  }
  
  formatDate(date: Date): string {
    return date.toLocaleDateString();
  }
}

// 业务类
class UserService {
  // 业务逻辑
}

// 混入工具功能
applyMixins(UserService, [Validation, Formatting]);

const service = new UserService() as UserService & Validation & Formatting;
console.log(service.validateEmail("test@example.com")); // true
console.log(service.formatCurrency(100)); // "$100.00"
```

### 2. 插件系统
```typescript
// 插件接口
interface Plugin {
  install(target: any): void;
}

// 具体插件
class LoggerPlugin implements Plugin {
  install(target: any) {
    target.prototype.log = function (message: string) {
      console.log(`[PLUGIN] ${message}`);
    };
  }
}

class MetricsPlugin implements Plugin {
  install(target: any) {
    target.prototype.track = function (event: string) {
      console.log(`Tracking: ${event}`);
    };
  }
}

// 应用插件
function applyPlugins(target: any, plugins: Plugin[]) {
  plugins.forEach(plugin => plugin.install(target));
}

class App {
  // 应用核心功能
}

applyPlugins(App, [new LoggerPlugin(), new MetricsPlugin()]);

const app = new App() as App & { log: (msg: string) => void } & { track: (event: string) => void };
app.log("Application started");
app.track("user_login");
```

### 3. 跨领域关注点
```typescript
// 横切关注点
class Observable {
  private listeners: Map<string, Function[]> = new Map();
  
  on(event: string, callback: Function) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(callback);
  }
  
  emit(event: string, ...args: any[]) {
    const callbacks = this.listeners.get(event) || [];
    callbacks.forEach(callback => callback(...args));
  }
}

// 业务类
class DataModel {
  data: any;
  
  update(data: any) {
    this.data = data;
  }
}

// 混入观察者功能
applyMixins(DataModel, [Observable]);

const model = new DataModel() as DataModel & Observable;
model.on("change", (newData: any) => {
  console.log("Data changed:", newData);
});

model.update({ name: "New Data" });
model.emit("change", model.data);
```

## 注意事项

### 类型安全
```typescript
// 使用交叉类型确保类型安全
type MixedClass = MyClass & Mixin1 & Mixin2;

const instance = new MyClass() as MixedClass;
instance.mixinMethod(); // 类型安全调用
```

### 命名冲突
```typescript
// 处理命名冲突
class MixinA {
  commonMethod() {
    console.log("From MixinA");
  }
}

class MixinB {
  commonMethod() {
    console.log("From MixinB");
  }
}

// 后混入的方法会覆盖先混入的方法
applyMixins(MyClass, [MixinA, MixinB]);

const instance = new MyClass() as MyClass & MixinA & MixinB;
instance.commonMethod(); // "From MixinB" (后混入的)
```

### 最佳实践
```typescript
// 使用装饰器实现类型安全的混入
function mixin(...mixins: any[]) {
  return function (target: any) {
    mixins.forEach(mixin => {
      Object.getOwnPropertyNames(mixin.prototype).forEach(name => {
        if (name !== "constructor") {
          Object.defineProperty(
            target.prototype,
            name,
            Object.getOwnPropertyDescriptor(mixin.prototype, name) ||
              Object.create(null)
          );
        }
      });
    });
  };
}

// 使用接口声明扩展
interface MyClass extends Mixin1, Mixin2 {}
```

## 示例代码位置

相关示例代码请查看：`examples/34-mixins.ts`

---

**上一节**: [33-装饰器](./33-装饰器.md)  
**下一节**: [35-命名空间](./35-命名空间.md)  
**返回目录**: [高级特性目录](../高级特性/)