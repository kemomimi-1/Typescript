# 38. 类型体操 (Type Gymnastics)

## 概念定义

**类型体操**是指使用 TypeScript 的高级类型特性来创建复杂、精巧的类型操作和转换。它结合了条件类型、映射类型、模板字面量类型等特性，用于实现类型级别的编程逻辑，让类型系统能够表达更复杂的约束和转换。

## 语法示例

### 条件类型与 infer
```typescript
// 提取函数返回类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// 提取函数参数类型
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// 提取数组元素类型
type ElementType<T> = T extends (infer U)[] ? U : never;

// 提取 Promise 的解析类型
type Awaited<T> = T extends Promise<infer U> ? U : T;

// 使用示例
type Func = (a: number, b: string) => boolean;
type FuncReturn = ReturnType<Func>; // boolean
type FuncParams = Parameters<Func>; // [number, string]

type NumArray = number[];
type NumElement = ElementType<NumArray>; // number

type PromiseString = Promise<string>;
type StringValue = Awaited<PromiseString>; // string
```

### 映射类型与键操作
```typescript
// 将对象的所有属性变为可选
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 将对象的所有属性变为必需
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 将对象的所有属性变为只读
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 选择对象的部分属性
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 排除对象的某些属性
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 使用示例
interface User {
  id: number;
  name: string;
  email: string;
  age?: number;
}

type UserPartial = Partial<User>; // 所有属性可选
type UserRequired = Required<User>; // 所有属性必需
type UserReadonly = Readonly<User>; // 所有属性只读
type UserNameOnly = Pick<User, 'name'>; // 只有 name 属性
type UserWithoutAge = Omit<User, 'age'>; // 排除 age 属性
```

### 模板字面量类型操作
```typescript
// 字符串拼接类型
type Greeting<T extends string> = `Hello, ${T}!`;
type WelcomeMessage = Greeting<'World'>; // "Hello, World!"

// CSS 类名生成
type Color = 'red' | 'blue' | 'green';
type Size = 'small' | 'medium' | 'large';
type ButtonClass = `btn-${Color}-${Size}`;
// "btn-red-small" | "btn-red-medium" | "btn-red-large" | ...

// 路径参数提取
type ExtractParams<Path> = 
  Path extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractParams<Rest>
    : Path extends `${string}:${infer Param}`
      ? Param
      : never;

type Params = ExtractParams<'/user/:id/posts/:postId'>; // "id" | "postId"

// 字符串转换
type UpperCase<S extends string> = 
  S extends `${infer First}${infer Rest}`
    ? `${Uppercase<First>}${LowerCase<Rest>}`
    : '';

type LowerCase<S extends string> = 
  S extends `${infer First}${infer Rest}`
    ? `${Lowercase<First>}${LowerCase<Rest>}`
    : '';
```

## 使用场景

### 1. API 路由类型安全
```typescript
// 定义路由类型
type Route = 
  | '/users'
  | '/users/:id'
  | '/posts'
  | '/posts/:id/comments'
  | '/posts/:id/comments/:commentId';

// 提取路由参数
type RouteParams<R extends string> = 
  R extends `${string}:${infer Param}/${infer Rest}`
    ? Param | RouteParams<Rest>
    : R extends `${string}:${infer Param}`
      ? Param
      : never;

// 创建类型安全的路由函数
function createRoute<R extends Route>(
  route: R,
  params: { [K in RouteParams<R>]: string | number }
): string {
  let result: string = route;
  for (const [key, value] of Object.entries(params)) {
    result = result.replace(`:${key}`, String(value));
  }
  return result;
}

// 使用示例
const userRoute = createRoute('/users/:id', { id: 123 }); // "/users/123"
const commentRoute = createRoute('/posts/:id/comments/:commentId', { 
  id: 456, 
  commentId: 789 
}); // "/posts/456/comments/789"

// 类型错误检测
// createRoute('/users/:id', { wrongParam: 123 }); // ❌ 错误：缺少 id 参数
// createRoute('/users', { id: 123 }); // ❌ 错误：不需要参数
```

### 2. 表单验证类型
```typescript
// 表单字段配置
type FieldConfig = {
  type: 'text' | 'number' | 'email' | 'password';
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
};

// 表单配置类型
type FormConfig = Record<string, FieldConfig>;

// 根据配置生成表单值类型
type FormValues<C extends FormConfig> = {
  [K in keyof C]: 
    C[K]['type'] extends 'number' ? number :
    string;
};

// 根据配置生成表单错误类型
type FormErrors<C extends FormConfig> = {
  [K in keyof C]?: string;
};

// 使用示例
const loginFormConfig = {
  username: { type: 'text', required: true, minLength: 3 },
  password: { type: 'password', required: true, minLength: 8 },
  age: { type: 'number', required: false }
};

type LoginValues = FormValues<typeof loginFormConfig>;
// { username: string; password: string; age: number }

type LoginErrors = FormErrors<typeof loginFormConfig>;
// { username?: string; password?: string; age?: string }

// 类型安全的表单处理函数
function validateForm<C extends FormConfig>(
  values: FormValues<C>,
  config: C
): FormErrors<C> {
  const errors: FormErrors<C> = {};
  
  for (const [key, fieldConfig] of Object.entries(config)) {
    const value = values[key as keyof FormValues<C>];
    
    if (fieldConfig.required && !value) {
      errors[key as keyof FormErrors<C>] = '此字段为必填项';
    }
    
    if (fieldConfig.minLength && typeof value === 'string' && value.length < fieldConfig.minLength) {
      errors[key as keyof FormErrors<C>] = `至少需要 ${fieldConfig.minLength} 个字符`;
    }
  }
  
  return errors;
}
```

### 3. 高级工具类型
```typescript
// 深度 Partial
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 深度 Required
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

// 深度 Readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 函数组合类型
type Compose<F extends Array<(arg: any) => any>> = 
  F extends [infer First, ...infer Rest]
    ? First extends (arg: infer Arg) => any
      ? Rest extends Array<(arg: any) => any>
        ? (arg: Arg) => ReturnType<Rest[Rest.length - 1]>
        : never
      : never
    : never;

// 使用示例
interface NestedData {
  user: {
    profile: {
      name: string;
      age?: number;
      address?: {
        street: string;
        city: string;
      };
    };
  };
}

type PartialNested = DeepPartial<NestedData>;
type RequiredNested = DeepRequired<NestedData>;
type ReadonlyNested = DeepReadonly<NestedData>;

// 函数组合
const add1 = (x: number) => x + 1;
const multiply2 = (x: number) => x * 2;
const toString = (x: number) => x.toString();

type Composed = Compose<[typeof add1, typeof multiply2, typeof toString]>;
// (arg: number) => string
```

## 注意事项

### 类型实例化深度
```typescript
// 避免无限递归类型
type Infinite<T> = T extends object ? Infinite<T> : T; // ❌ 可能导致无限类型

// 使用深度限制
type DeepPartialWithLimit<T, Depth extends number = 3> = 
  Depth extends 0 
    ? T 
    : {
        [P in keyof T]?: 
          T[P] extends object 
            ? DeepPartialWithLimit<T[P], Depth extends 0 ? 0 : Depth-1> 
            : T[P];
      };
```

### 性能考虑
```typescript
// 复杂的类型操作可能影响编译性能
// 避免在大型项目中使用过于复杂的类型体操

// 使用类型别名缓存中间结果
type UserKeys = keyof User;
type OptionalUserKeys = { [K in UserKeys]?: User[K] };

// 而不是每次都重新计算
function processUser(user: { [K in keyof User]?: User[K] }) {}
```

### 最佳实践
```typescript
// 1. 保持类型操作简单明了
// 2. 使用文档说明复杂类型
// 3. 考虑使用工具类型库（如 type-fest）
// 4. 测试复杂类型的行为
// 5. 避免过度工程化

// 实用的工具类型
type ValueOf<T> = T[keyof T];
type Entry<T> = [keyof T, ValueOf<T>];
type Entries<T> = Entry<T>[];

function objectEntries<T extends object>(obj: T): Entries<T> {
  return Object.entries(obj) as Entries<T>;
}

// 类型安全的 Object.entries
const user = { name: 'Alice', age: 30 };
const entries = objectEntries(user); // [['name', 'Alice'], ['age', 30]]
```

## 示例代码位置

相关示例代码请查看：`examples/38-type-gymnastics.ts`

---

**上一节**: [37-类型兼容性](./37-类型兼容性.md)  
**返回目录**: [高级特性目录](../高级特性/)
**返回总目录**: [TypeScript学习笔记](../)