# 泛型类

泛型类允许在类定义中使用类型参数，这些参数在实例化类时指定。这使得类可以处理多种数据类型，而无需为每种类型编写单独的类。泛型类类似于泛型函数，但应用于类的属性和方法。

## 为什么使用泛型类？
- **代码重用**：一个类可以处理字符串、数字、对象等。
- **类型安全**：确保类的方法只接受和返回正确的类型。
- **灵活性**：支持约束和默认类型。

## 基本示例：栈实现
一个简单的泛型栈类。

```typescript
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }
}

const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
console.log(numberStack.pop()); // 2
console.log(numberStack.peek()); // 1
```

## 带约束的泛型类
添加约束以限制类型参数。

```typescript
class KeyValuePair<K extends string | number, V> {
  private key: K;
  private value: V;

  constructor(key: K, value: V) {
    this.key = key;
    this.value = value;
  }

  getKey(): K {
    return this.key;
  }

  getValue(): V {
    return this.value;
  }
}

const pair = new KeyValuePair('name', 'Alice'); // 有效
// const invalid = new KeyValuePair(true, 'test'); // 错误：boolean 不符合 string | number
```

## 泛型类与继承
泛型类可以被继承，并传递或添加类型参数。

```typescript
class BaseRepository<T> {
  protected items: T[] = [];
  add(item: T) { this.items.push(item); }
}

class UserRepository extends BaseRepository<{ id: number; name: string }> {
  findById(id: number): { id: number; name: string } | undefined {
    return this.items.find(item => item.id === id);
  }
}

const repo = new UserRepository();
repo.add({ id: 1, name: 'Alice' });
console.log(repo.findById(1)); // { id: 1, name: 'Alice' }
```

## 注意事项
- **静态成员**：静态属性/方法不能使用类的泛型参数，因为静态成员在实例化前存在。
- **默认类型**：可以指定默认，如 `class Stack<T = any> { ... }`，但避免 any 以保持类型安全。
- **多个泛型参数**：如 `class Map<K, V> { ... }`，类似于内置 Map。
- **常见错误**：忘记在实例化时指定类型会导致推断为 any。
- **性能**：泛型类在编译时被擦除，不会影响运行时性能。

泛型类是构建库和框架的关键工具。如果您有特定类的实现需求，我可以提供更多细节！