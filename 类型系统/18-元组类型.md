# TypeScript 元组类型

## 概述
元组（Tuple）类型表示一个已知元素数量和类型的数组，各元素的类型不必相同。元组提供了对固定长度数组的精确类型控制。

## 基本语法

### 基本元组定义
```typescript
// 简单的字符串和数字元组
let person: [string, number] = ["Alice", 25];

// 混合类型元组
let mixed: [string, number, boolean] = ["hello", 42, true];
```

### 元组类型注解
```typescript
// 函数返回元组
function getPerson(): [string, number] {
  return ["Bob", 30];
}

// 函数参数为元组
function processTuple([name, age]: [string, number]): void {
  console.log(`Name: ${name}, Age: ${age}`);
}
```

## 元组操作

### 访问元组元素
```typescript
let point: [number, number] = [10, 20];

// 通过索引访问
const x = point[0]; // number
const y = point[1]; // number

// 解构赋值
const [first, second] = point;
console.log(first, second); // 10, 20
```

### 修改元组元素
```typescript
let user: [string, number] = ["Alice", 25];

// 修改元素
user[0] = "Bob";     // 正确
user[1] = 30;        // 正确
// user[1] = "30";   // 错误：不能将 string 赋值给 number

// 重新赋值整个元组
user = ["Charlie", 35]; // 正确
```

## 可选元素元组

### 可选元素
```typescript
// 可选元素使用 ?
let optionalTuple: [string, number?] = ["Alice"]; // 第二个元素可选
optionalTuple = ["Bob", 30]; // 也可以提供第二个元素

// 多个可选元素
let multiOptional: [string, number?, boolean?] = ["hello"];
multiOptional = ["world", 42];
multiOptional = ["!", 123, true];
```

### 访问可选元素
```typescript
function processUser([name, age]: [string, number?]): void {
  console.log(`Name: ${name}`);
  if (age !== undefined) {
    console.log(`Age: ${age}`);
  }
}
```

## 剩余元素元组

### 剩余元素
```typescript
// 剩余元素使用 ...
let restTuple: [string, ...number[]] = ["scores", 90, 85, 95];

// 剩余元素可以是任意类型
let mixedRest: [string, boolean, ...any[]] = ["data", true, 42, "hello"];
```

### 函数中的剩余元组
```typescript
function scores(name: string, ...scores: number[]): [string, ...number[]] {
  return [name, ...scores];
}

const result = scores("Alice", 90, 85, 95); // ["Alice", 90, 85, 95]
```

## 只读元组

### 只读元组
```typescript
// 使用 readonly 修饰符
const readOnlyPoint: readonly [number, number] = [10, 20];

// readOnlyPoint[0] = 15; // 错误：不能修改只读元组
// readOnlyPoint.push(30); // 错误：只读元组没有 push 方法

// 使用 Readonly 工具类型
type ReadonlyPoint = Readonly<[number, number]>;
const point: ReadonlyPoint = [10, 20];
```

### 只读元组的好处
```typescript
// 保证数据不变性
function createPoint(x: number, y: number): readonly [number, number] {
  return [x, y];
}

const point = createPoint(10, 20);
// point[0] = 15; // 编译时错误
```

## 元组与数组的区别

### 类型安全
```typescript
// 数组：所有元素类型相同
let array: number[] = [1, 2, 3];
array.push(4);     // 正确
array.push("4");   // 错误：不能将 string 赋值给 number

// 元组：固定类型和长度
let tuple: [string, number] = ["Alice", 25];
tuple.push("extra"); // 运行时可以，但类型不安全
```

### 长度约束
```typescript
let tuple: [string, number] = ["Alice", 25];

// 访问超出范围的元素
// const third = tuple[2]; // 类型错误：长度为 2 的元组类型在索引 2 处没有元素
```

## 实用模式

### 1. 函数多返回值
```typescript
function parseInput(input: string): [boolean, string?] {
  if (input === "") {
    return [false, "Input cannot be empty"];
  }
  return [true];
}

const [success, error] = parseInput("");
if (!success) {
  console.error(error);
}
```

### 2. React Hook 状态
```typescript
// useState 返回元组
const [state, setState] = useState<string>("");

// 自定义 Hook 返回元组
function useCounter(): [number, () => void, () => void] {
  const [count, setCount] = useState(0);
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  return [count, increment, decrement];
}
```

### 3. 配置对象
```typescript
function createConfig([host, port, ssl = false]: [string, number, boolean?]): Config {
  return { host, port, ssl };
}

const config = createConfig(["localhost", 8080]);
```

### 4. 数据转换
```typescript
function parseCsvLine(line: string): [string, number, Date] {
  const [name, ageStr, dateStr] = line.split(",");
  return [name, parseInt(ageStr), new Date(dateStr)];
}
```

## 元组工具类型

### 1. 获取元组长度
```typescript
type Length<T extends any[]> = T["length"];

type PointLength = Length<[number, number]>; // 2
type TripleLength = Length<[number, number, number]>; // 3
```

### 2. 获取元组元素类型
```typescript
type First<T extends any[]> = T[0];
type Second<T extends any[]> = T[1];

type NameType = First<[string, number]>; // string
type AgeType = Second<[string, number]>; // number
```

### 3. 连接元组
```typescript
type Concat<T extends any[], U extends any[]> = [...T, ...U];

type Combined = Concat<[string], [number, boolean]>; // [string, number, boolean]
```

## 最佳实践

### 1. 使用具名元组（TypeScript 4.0+）
```typescript
// 使用标签提供更好的文档
function getPerson(): [name: string, age: number] {
  return ["Alice", 25];
}

const [name, age] = getPerson(); // 编辑器会显示标签
```

### 2. 优先使用对象而不是长元组
```typescript
// 避免过长的元组
// 不好：难以理解每个位置的用途
let longTuple: [string, number, boolean, string, number] = ["Alice", 25, true, "Bob", 30];

// 更好：使用对象字面量
let person = {
  name: "Alice",
  age: 25,
  isActive: true,
  friendName: "Bob",
  friendAge: 30
};
```

### 3. 使用只读元组保护数据
```typescript
// 返回只读元组防止意外修改
function getCoordinates(): readonly [number, number] {
  return [10, 20];
}

const coords = getCoordinates();
// coords[0] = 15; // 编译时错误
```

### 4. 为元组提供类型别名
```typescript
// 使用类型别名提高可读性
type Point = [number, number];
type Person = [string, number];
type HttpResponse = [number, string, any?];

function drawPoint(point: Point): void {
  const [x, y] = point;
  // ...
}
```

## 常见错误

### 1. 混淆元组和数组
```typescript
let tuple: [string, number] = ["Alice", 25];
let array: (string | number)[] = ["Alice", 25];

// 虽然看起来相似，但类型不同
tuple = array; // 错误：类型不匹配
array = tuple; // 正确：元组可以赋值给数组
```

### 2. 忽略元组长度
```typescript
let point: [number, number] = [10, 20];

// 尝试访问不存在的元素
// const z = point[2]; // 错误：索引 2 处没有元素

// 尝试修改为不同长度
// point = [10]; // 错误：缺少元素
// point = [10, 20, 30]; // 错误：多余元素
```

### 3. 误用剩余元素
```typescript
let scores: [string, ...number[]] = ["Alice"]; // 正确
scores = ["Bob", 90, 85]; // 正确

// 但类型检查可能不如预期严格
scores = ["Charlie", "invalid"]; // 错误：string 不能赋值给 number
```

## 练习建议

1. 创建各种类型的元组并练习访问元素
2. 使用元组作为函数的多返回值
3. 练习元组解构和模式匹配
4. 创建只读元组并体验其不可变性
5. 比较元组和数组的类型安全性差异

---
最后更新: 2025-11-20