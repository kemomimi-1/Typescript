# TypeScript 接口

## 概述
接口（Interface）是 TypeScript 的核心概念之一，用于定义对象的形状和契约。接口提供了强大的类型检查能力，支持声明合并和扩展。

## 基本语法

### 简单接口定义
```typescript
interface Person {
  name: string;
  age: number;
}
```

### 使用接口
```typescript
const person: Person = {
  name: "Alice",
  age: 25
};

function greet(person: Person): string {
  return `Hello, ${person.name}!`;
}
```

## 接口特性

### 可选属性
```typescript
interface User {
  id: number;
  name: string;
  email?: string; // 可选属性
}
```

### 只读属性
```typescript
interface Config {
  readonly apiKey: string; // 只读属性
  readonly endpoint: string;
}

const config: Config = { apiKey: "123", endpoint: "/api" };
// config.apiKey = "new"; // 错误：无法分配到只读属性
```

### 函数类型
```typescript
interface SearchFunc {
  (source: string, subString: string): boolean;
}

const mySearch: SearchFunc = function(source, subString) {
  return source.includes(subString);
};
```

### 索引签名
```typescript
interface StringArray {
  [index: number]: string;
}

const myArray: StringArray = ["a", "b", "c"];
console.log(myArray[0]); // "a"
```

## 接口扩展

### 单接口扩展
```typescript
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
  bark(): void;
}

const myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
  bark: () => console.log("Woof!")
};
```

### 多接口扩展
```typescript
interface CanSwim {
  swim(): void;
}

interface CanFly {
  fly(): void;
}

interface Duck extends CanSwim, CanFly {
  name: string;
}

const donald: Duck = {
  name: "Donald",
  swim: () => console.log("Swimming"),
  fly: () => console.log("Flying")
};
```

## 接口与类

### 类实现接口
```typescript
interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date();
  
  setTime(d: Date): void {
    this.currentTime = d;
  }
}
```

### 实现多个接口
```typescript
interface Alarm {
  alert(): void;
}

interface Light {
  lightOn(): void;
  lightOff(): void;
}

class Car implements Alarm, Light {
  alert(): void {
    console.log("Car alarm!");
  }
  
  lightOn(): void {
    console.log("Lights on");
  }
  
  lightOff(): void {
    console.log("Lights off");
  }
}
```

## 高级接口特性

### 混合类型
```typescript
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  const counter = function(start: number) {} as Counter;
  counter.interval = 123;
  counter.reset = function() {};
  return counter;
}
```

### 接口继承类
```typescript
class Control {
  private state: any;
}

interface SelectableControl extends Control {
  select(): void;
}

class Button extends Control implements SelectableControl {
  select(): void {}
}
```

## 接口与类型别名

### 接口 vs 类型别名
```typescript
// 接口
interface Point {
  x: number;
  y: number;
}

// 类型别名
type Point = {
  x: number;
  y: number;
};
```

### 接口的优势
```typescript
// 接口支持声明合并
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}

const win: Window = {
  title: "My App",
  ts: {} as TypeScriptAPI
};
```

## 泛型接口

### 基本泛型接口
```typescript
interface Box<T> {
  value: T;
}

const numberBox: Box<number> = { value: 42 };
const stringBox: Box<string> = { value: "hello" };
```

### 函数泛型接口
```typescript
interface Pair<T, U> {
  first: T;
  second: U;
}

const pair: Pair<number, string> = { first: 1, second: "one" };
```

### 约束泛型接口
```typescript
interface Lengthwise {
  length: number;
}

interface Loggable<T extends Lengthwise> {
  log(value: T): void;
}

const logger: Loggable<string> = {
  log: (value) => console.log(value.length)
};
```

## 接口最佳实践

### 1. 使用接口定义公共API
```typescript
// 好的实践：使用接口定义API响应
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}
```

### 2. 优先使用接口而不是内联类型
```typescript
// 好的实践
interface User {
  id: number;
  name: string;
}

function getUser(): User { /* ... */ }

// 避免
function getUser(): { id: number; name: string } { /* ... */ }
```

### 3. 使用接口扩展而不是重复定义
```typescript
interface BaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
}

interface Product extends BaseEntity {
  name: string;
  price: number;
}
```

### 4. 文档化接口
```typescript
/**
 * 用户信息接口
 * @property id - 用户唯一标识
 * @property name - 用户姓名
 * @property email - 用户邮箱（可选）
 */
interface User {
  id: number;
  name: string;
  email?: string;
}
```

## 实用技巧

### 1. 使用索引签名处理动态属性
```typescript
interface Config {
  [key: string]: string | number;
  name: string;
  timeout: number;
}
```

### 2. 使用映射类型修改接口
```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

type ReadonlyUser = Readonly<User>;
type PartialUser = Partial<User>;
```

### 3. 条件类型与接口
```typescript
type NonFunctionKeys<T> = {
  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];

type UserProperties = Pick<User, NonFunctionKeys<User>>;
```

### 4. 接口与模板字面量类型
```typescript
interface EventMap {
  click: MouseEvent;
  keydown: KeyboardEvent;
  [event: `on${string}`]: Event;
}
```

## 常见错误

### 1. 混淆接口和类型别名
```typescript
// 接口可以扩展
type A = { x: number };
interface B extends A { y: number; } // 正确

// 类型别名使用交叉类型
type C = A & { y: number }; // 正确
```

### 2. 忘记实现接口的所有成员
```typescript
interface Animal {
  name: string;
  sound(): void;
}

class Dog implements Animal {
  name: string = "Buddy";
  // 忘记实现 sound() 方法 - 错误
}
```

### 3. 索引签名冲突
```typescript
interface Problematic {
  [key: string]: string;
  age: number; // 错误：number 不能赋值给 string
}
```

## 练习建议

1. 创建各种类型的接口（对象、函数、索引等）
2. 练习接口扩展和实现
3. 比较接口和类型别名的区别
4. 使用泛型接口创建可重用类型
5. 体验接口的声明合并特性

---
最后更新: 2025-11-20