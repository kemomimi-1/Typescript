# TypeScript 接口 vs 类型别名

## 概述
接口（Interface）和类型别名（Type Alias）都是 TypeScript 中定义类型的方式，但它们有不同的特性和适用场景。理解它们的区别对于编写高质量的 TypeScript 代码至关重要。

## 基本语法对比

### 接口定义
```typescript
interface Point {
  x: number;
  y: number;
}
```

### 类型别名定义
```typescript
type Point = {
  x: number;
  y: number;
};
```

## 主要区别

### 1. 声明合并（Declaration Merging）

#### 接口支持声明合并
```typescript
interface User {
  name: string;
}

interface User {
  age: number;
}

// 合并后的 User 接口
const user: User = {
  name: "Alice",
  age: 25
};
```

#### 类型别名不支持声明合并
```typescript
type User = {
  name: string;
};

// 错误：重复标识符 'User'
type User = {
  age: number;
};
```

### 2. 扩展方式

#### 接口扩展（extends）
```typescript
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}
```

#### 类型别名扩展（交叉类型）
```typescript
type Animal = {
  name: string;
};

type Dog = Animal & {
  breed: string;
};
```

### 3. 实现（implements）

#### 接口可以被类实现
```typescript
interface Logger {
  log(message: string): void;
}

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(message);
  }
}
```

#### 类型别名也可以被类实现
```typescript
type Logger = {
  log(message: string): void;
};

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(message);
  }
}
```

## 适用场景

### 优先使用接口的场景

#### 1. 定义对象形状
```typescript
// 好的实践：使用接口定义对象结构
interface User {
  id: number;
  name: string;
  email?: string;
}
```

#### 2. 类实现契约
```typescript
interface Serializable {
  serialize(): string;
  deserialize(data: string): void;
}

class User implements Serializable {
  serialize(): string { /* ... */ }
  deserialize(data: string): void { /* ... */ }
}
```

#### 3. 声明合并（扩展第三方类型）
```typescript
// 扩展全局 Window 对象
interface Window {
  myApp: any;
}

// 扩展第三方库类型
declare module "some-library" {
  interface Config {
    customOption: boolean;
  }
}
```

### 优先使用类型别名的场景

#### 1. 联合类型（Union Types）
```typescript
// 类型别名更适合联合类型
type Status = "pending" | "success" | "error";
type ID = number | string;
```

#### 2. 元组类型（Tuple Types）
```typescript
// 类型别名更适合元组
type Point = [number, number];
type UserTuple = [number, string, string?];
```

#### 3. 映射类型（Mapped Types）
```typescript
// 类型别名更适合复杂类型操作
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

#### 4. 条件类型（Conditional Types）
```typescript
// 类型别名更适合条件类型
type NonNullable<T> = T extends null | undefined ? never : T;
type Extract<T, U> = T extends U ? T : never;
```

## 性能考虑

### 接口的性能优势
```typescript
// 接口在大型代码库中可能有更好的性能
interface LargeObject {
  prop1: string;
  prop2: number;
  // ... 很多属性
}

// 类型别名在复杂类型操作时可能更高效
type ComplexType = SomeType & AnotherType | ThirdType;
```

## 错误信息

### 接口的错误信息
```typescript
interface User { name: string; }
const user: User = { name: 123 }; // 错误：类型 'number' 不能赋值给 'string'
```

### 类型别名的错误信息
```typescript
type User = { name: string; };
const user: User = { name: 123 }; // 错误：类型 'number' 不能赋值给 'string'
```

## 工具支持

### 自动完成和智能提示
```typescript
interface User {
  /** 用户姓名 */
  name: string;
  /** 用户年龄 */
  age: number;
}

const user: User = {
  // 编辑器会显示属性的文档
};
```

## 最佳实践

### 1. 默认使用接口
```typescript
// 对于对象形状，优先使用接口
interface Config {
  host: string;
  port: number;
  timeout?: number;
}
```

### 2. 需要联合类型时使用类型别名
```typescript
// 联合类型使用类型别名
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type Result<T> = { success: true; data: T } | { success: false; error: string };
```

### 3. 扩展第三方类型时使用接口
```typescript
// 扩展第三方库使用接口
declare module "axios" {
  interface AxiosRequestConfig {
    customTimeout?: number;
  }
}
```

### 4. 复杂类型操作时使用类型别名
```typescript
// 复杂类型操作使用类型别名
type DeepReadonly<T> = {
  readonly [P in keyof T]: DeepReadonly<T[P]>;
};

type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];
```

## 常见误区

### 1. 认为接口只能用于对象
```typescript
// 接口也可以用于函数类型
interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

### 2. 认为类型别名不能扩展
```typescript
// 类型别名可以通过交叉类型扩展
type Animal = { name: string; };
type Dog = Animal & { breed: string; };
```

### 3. 过度使用类型别名
```typescript
// 避免不必要的类型别名
type String = string; // 不必要的别名
type Number = number; // 不必要的别名
```

## 迁移建议

### 从类型别名迁移到接口
```typescript
// 如果之前使用类型别名
type User = {
  id: number;
  name: string;
};

// 可以迁移到接口
interface User {
  id: number;
  name: string;
}
```

### 从接口迁移到类型别名
```typescript
// 如果之前使用接口
interface Status {
  value: "pending" | "success" | "error";
}

// 对于联合类型，更适合使用类型别名
type Status = "pending" | "success" | "error";
```

## 团队规范

### 制定团队规范
```typescript
// 示例团队规范：
// 1. 对象形状使用接口
// 2. 联合类型使用类型别名  
// 3. 元组类型使用类型别名
// 4. 复杂类型操作使用类型别名
// 5. 扩展第三方类型使用接口
```

## 练习建议

1. 创建相同的类型分别使用接口和类型别名
2. 体验接口的声明合并特性
3. 练习使用交叉类型扩展类型别名
4. 比较两者的错误信息和开发体验
5. 制定个人或团队的使用规范

---
最后更新: 2025-11-20