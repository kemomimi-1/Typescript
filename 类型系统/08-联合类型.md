# TypeScript 联合类型

## 概述
联合类型允许一个值可以是多种类型之一，使用 `|` 运算符连接多个类型。

## 基本语法

### 简单联合类型
```typescript
let id: string | number = "123";
id = 456; // 也允许
```

### 多类型联合
```typescript
let value: string | number | boolean = "hello";
value = 42;
value = true;
```

## 常见使用场景

### 1. 处理多种可能的输入
```typescript
function processInput(input: string | number) {
  if (typeof input === "string") {
    return input.toUpperCase();
  } else {
    return input.toFixed(2);
  }
}
```

### 2. API 响应处理
```typescript
type ApiResponse = User | Error | null;

function handleResponse(response: ApiResponse) {
  if (response instanceof Error) {
    console.error(response.message);
  } else if (response) {
    console.log(response.name);
  }
}
```

### 3. 配置选项
```typescript
type Theme = "light" | "dark" | "auto";

function setTheme(theme: Theme) {
  // 应用主题
}
```

## 类型守卫

### typeof 类型守卫
```typescript
function processValue(value: string | number) {
  if (typeof value === "string") {
    // value 是 string 类型
    console.log(value.length);
  } else {
    // value 是 number 类型
    console.log(value.toFixed(2));
  }
}
```

### instanceof 类型守卫
```typescript
class CustomError extends Error {}

function handleError(error: Error | CustomError) {
  if (error instanceof CustomError) {
    // 处理自定义错误
  } else {
    // 处理一般错误
  }
}
```

### 自定义类型守卫
```typescript
function isString(value: any): value is string {
  return typeof value === "string";
}

function process(value: string | number) {
  if (isString(value)) {
    console.log(value.toUpperCase());
  }
}
```

## 字面量联合类型

### 字符串字面量联合
```typescript
type Direction = "north" | "south" | "east" | "west";
let direction: Direction = "north";
// direction = "up"; // 错误
```

### 数字字面量联合
```typescript
type Dice = 1 | 2 | 3 | 4 | 5 | 6;
let roll: Dice = 3;
// roll = 7; // 错误
```

### 混合字面量联合
```typescript
type Status = "success" | "error" | 404 | 500;
let status: Status = "success";
status = 404;
```

## 联合类型与数组

### 联合类型数组
```typescript
let mixed: (string | number)[] = [1, "hello", 2, "world"];
```

### 处理联合类型数组
```typescript
function processArray(arr: (string | number)[]) {
  arr.forEach(item => {
    if (typeof item === "string") {
      console.log(`String: ${item}`);
    } else {
      console.log(`Number: ${item}`);
    }
  });
}
```

## 联合类型与函数

### 函数参数联合类型
```typescript
function formatValue(value: string | number): string {
  if (typeof value === "number") {
    return value.toFixed(2);
  }
  return value;
}
```

### 函数返回值联合类型
```typescript
function parseInput(input: string): number | null {
  const result = Number(input);
  return isNaN(result) ? null : result;
}
```

## 联合类型与对象

### 对象属性联合
```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
  }
}
```

## 可辨识联合

### 使用标签区分类型
```typescript
type NetworkState = 
  | { state: "loading" }
  | { state: "success"; data: string }
  | { state: "error"; error: Error };

function handleState(state: NetworkState) {
  switch (state.state) {
    case "loading":
      console.log("Loading...");
      break;
    case "success":
      console.log("Data:", state.data);
      break;
    case "error":
      console.error("Error:", state.error.message);
      break;
  }
}
```

## 类型收缩

### 使用类型断言
```typescript
function processValue(value: string | number) {
  if ((value as string).toUpperCase) {
    console.log((value as string).toUpperCase());
  }
}
```

### 使用类型谓词
```typescript
function isNumber(value: any): value is number {
  return typeof value === "number";
}

function process(value: string | number) {
  if (isNumber(value)) {
    console.log(value.toFixed(2));
  }
}
```

## 联合类型操作

### 提取公共成员
```typescript
interface A { a: number; b: string; }
interface B { a: number; c: boolean; }

type Union = A | B;
let value: Union = { a: 1, b: "hello" };

console.log(value.a); // 可以访问，因为 a 是公共成员
// console.log(value.b); // 错误：b 不是公共成员
```

### 使用类型守卫访问特定成员
```typescript
function isA(value: Union): value is A {
  return "b" in value;
}

function process(value: Union) {
  if (isA(value)) {
    console.log(value.b); // 可以访问
  }
}
```

## 最佳实践

### 1. 使用可辨识联合
```typescript
// 好的实践
type Result = 
  | { type: "success"; data: any }
  | { type: "error"; message: string };
```

### 2. 避免过度使用 any
```typescript
// 避免
function process(value: any) {}

// 推荐
function process(value: string | number) {}
```

### 3. 使用类型守卫
```typescript
// 明确的类型检查
function process(value: string | number) {
  if (typeof value === "string") {
    // 处理字符串
  }
}
```

### 4. 限制联合类型数量
```typescript
// 避免过多的联合类型
type TooMany = string | number | boolean | null | undefined | object | any[];

// 保持合理数量
type Reasonable = string | number | boolean;
```

## 常见错误

### 1. 忘记类型检查
```typescript
function dangerous(value: string | number) {
  // console.log(value.toUpperCase()); // 错误：number 没有 toUpperCase
}
```

### 2. 混淆联合类型和交叉类型
```typescript
type Union = string | number; // 可以是 string 或 number
type Intersection = string & number; // never 类型（没有值同时是 string 和 number）
```

### 3. 过度复杂的联合类型
```typescript
// 难以维护
type Complex = 
  | { type: "a"; a: string }
  | { type: "b"; b: number }
  | { type: "c"; c: boolean }
  | { type: "d"; d: any[] };
```

## 练习建议

1. 创建不同的联合类型并添加类型注解
2. 练习使用 typeof 和 instanceof 类型守卫
3. 实现可辨识联合模式
4. 处理 API 响应数据的联合类型
5. 体验类型收缩和类型断言

---
最后更新: 2025-11-20