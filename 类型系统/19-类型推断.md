# TypeScript 类型推断

## 概述
类型推断（Type Inference）是 TypeScript 的核心特性之一，它能够自动推断变量、函数返回值等的类型，减少显式类型注解的需要，同时保持类型安全。

## 基本类型推断

### 变量类型推断
```typescript
// 自动推断为 string 类型
let name = "Alice";
// name = 123; // 错误：不能将 number 赋值给 string

// 自动推断为 number 类型
let age = 25;
// age = "25"; // 错误：不能将 string 赋值给 number

// 自动推断为 boolean 类型
let isActive = true;
// isActive = "true"; // 错误：不能将 string 赋值给 boolean
```

### 数组类型推断
```typescript
// 推断为 number[]
let numbers = [1, 2, 3];
// numbers.push("4"); // 错误：不能将 string 赋值给 number

// 推断为 (string | number)[]
let mixed = [1, "two", 3];
mixed.push(4);    // 正确
mixed.push("four"); // 正确
// mixed.push(true); // 错误：不能将 boolean 赋值给 string | number
```

### 对象类型推断
```typescript
// 自动推断对象类型
const person = {
  name: "Alice",
  age: 25,
  isActive: true
};

// person.email = "alice@example.com"; // 错误：对象字面量只能指定已知属性
// person.age = "25"; // 错误：不能将 string 赋值给 number
```

## 函数类型推断

### 函数参数推断
```typescript
// 参数类型需要显式注解或从上下文推断
function greet(name: string) {
  return `Hello, ${name}!`;
}

// 返回值自动推断为 string
const message = greet("Alice");
// message = 123; // 错误：不能将 number 赋值给 string
```

### 上下文类型推断
```typescript
// 根据函数类型推断参数类型
const users = ["Alice", "Bob", "Charlie"];

// map 回调参数根据数组元素类型推断
const lengths = users.map(user => user.length); // 推断为 number[]

// 根据函数签名推断
function processUser(callback: (name: string) => number) {
  return callback("test");
}

// name 自动推断为 string
const result = processUser(name => name.length);
```

### 函数返回值推断
```typescript
// 自动推断返回值类型
function add(a: number, b: number) {
  return a + b; // 推断为 number
}

function createUser(name: string, age: number) {
  return { name, age }; // 推断为 { name: string; age: number }
}
```

## 最佳公共类型推断

### 联合类型推断
```typescript
// 推断为 (string | number)[]
let values = [0, 1, "two"];

// 推断为 (boolean | null)[]
let flags = [true, false, null];

// 推断为 (number | string | boolean)[]
let mixedArray = [1, "hello", true];
```

### 上下文最佳公共类型
```typescript
// 根据上下文推断更具体的类型
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

// 推断为 Animal[]
let animals = [new Dog(), new Cat()];

// 如果明确注解，可以推断为更具体的类型
let pets: Dog[] = [new Dog(), new Dog()];
```

## 字面量类型推断

### 常量推断
```typescript
// const 声明的常量推断为字面量类型
const name = "Alice";      // 类型为 "Alice"
const age = 25;            // 类型为 25
const isActive = true;     // 类型为 true

// 对象字面量推断
const config = {
  theme: "dark" as const,  // 字面量类型 "dark"
  fontSize: 14 as const    // 字面量类型 14
};
```

### 数组字面量推断
```typescript
// 使用 as const 推断为元组字面量类型
const point = [10, 20] as const; // 类型为 readonly [10, 20]

// point[0] = 15; // 错误：不能修改只读元组

const colors = ["red", "green", "blue"] as const; // 类型为 readonly ["red", "green", "blue"]
```

## 上下文类型推断

### 回调函数参数推断
```typescript
// 根据函数类型推断回调参数
document.addEventListener("click", function(event) {
  // event 自动推断为 MouseEvent
  console.log(event.clientX, event.clientY);
});

// 数组方法的类型推断
const numbers = [1, 2, 3, 4, 5];
const evens = numbers.filter(n => n % 2 === 0); // n 推断为 number
```

### Promise 类型推断
```typescript
// Promise 解析值的类型推断
async function fetchData() {
  return { name: "Alice", age: 25 }; // 推断为 Promise<{ name: string; age: number }>
}

fetchData().then(data => {
  // data 推断为 { name: string; age: number }
  console.log(data.name, data.age);
});
```

## 类型推断的限制

### 需要显式注解的场景
```typescript
// 函数参数需要显式注解
function process(data: any) {
  return data; // 无法推断参数类型
}

// 空数组需要显式注解
let emptyArray = []; // 类型为 any[]
emptyArray.push(1);
emptyArray.push("hello"); // 允许，但类型不安全

// 更好的方式：显式注解
let numbers: number[] = [];
numbers.push(1);
// numbers.push("hello"); // 错误
```

### 复杂对象推断
```typescript
// 复杂对象可能需要显式注解
const complexConfig = {
  server: {
    host: "localhost",
    port: 8080
  },
  database: {
    name: "test",
    poolSize: 10
  }
} as const; // 使用 as const 获得更精确的类型
```

## 类型推断工具

### typeof 操作符
```typescript
const person = { name: "Alice", age: 25 };

// 使用 typeof 获取类型
type Person = typeof person; // { name: string; age: number }

function createPerson(data: typeof person): Person {
  return { ...data };
}
```

### keyof 操作符
```typescript
const config = {
  theme: "dark",
  fontSize: 14,
  language: "en"
};

// 获取对象键的类型
type ConfigKey = keyof typeof config; // "theme" | "fontSize" | "language"

function getConfigValue(key: ConfigKey) {
  return config[key];
}
```

## 最佳实践

### 1. 让 TypeScript 推断简单类型
```typescript
// 好的实践：让 TypeScript 推断简单类型
const name = "Alice"; // 自动推断为 string
const age = 25;       // 自动推断为 number
const scores = [90, 85, 95]; // 自动推断为 number[]
```

### 2. 为函数参数添加显式注解
```typescript
// 好的实践：为函数参数添加类型注解
function calculateTotal(price: number, quantity: number): number {
  return price * quantity;
}

// 避免：依赖类型推断可能导致意外行为
function calculateTotal(price, quantity) {
  return price * quantity; // price 和 quantity 推断为 any
}
```

### 3. 使用 const 断言获得精确类型
```typescript
// 使用 as const 获得字面量类型
const COLORS = ["red", "green", "blue"] as const;
// 类型为 readonly ["red", "green", "blue"]

type Color = typeof COLORS[number]; // "red" | "green" | "blue"
```

### 4. 为复杂对象添加接口
```typescript
// 好的实践：为复杂对象定义接口
interface Config {
  server: {
    host: string;
    port: number;
  };
  database: {
    name: string;
    poolSize: number;
  };
}

const config: Config = {
  server: { host: "localhost", port: 8080 },
  database: { name: "test", poolSize: 10 }
};
```

## 常见错误

### 1. 过度依赖类型推断
```typescript
// 避免：过度依赖推断可能导致类型不明确
function processData(data) { // data 推断为 any
  return data.value * 2; // 可能运行时错误
}
```

### 2. 忽略空数组的类型
```typescript
// 避免：空数组推断为 any[]
let items = []; // any[]
items.push(1);
items.push("hello"); // 允许但类型不安全

// 好的实践：显式注解
let numbers: number[] = [];
```

### 3. 混淆 let 和 const 的推断
```typescript
// let 允许重新赋值，推断为基本类型
let name = "Alice"; // string
name = "Bob"; // 正确

// const 不允许重新赋值，推断为字面量类型
const age = 25; // 25
// age = 26; // 错误
```

## 实用技巧

### 1. 使用 satisfies 操作符（TypeScript 4.9+）
```typescript
// 检查类型但不改变推断类型
const config = {
  theme: "dark",
  fontSize: 14
} satisfies { theme: string; fontSize: number };

// config.theme 仍然是 string 类型，不是 "dark" 字面量
```

### 2. 使用类型查询
```typescript
// 根据现有值推断类型
const defaultUser = { name: "", age: 0, active: false };

type User = typeof defaultUser;
// { name: string; age: number; active: boolean }
```

### 3. 条件类型推断
```typescript
// 在条件类型中使用 infer
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() { return { name: "Alice", age: 25 }; }
type User = ReturnType<typeof getUser>; // { name: string; age: number }
```

## 练习建议

1. 练习各种场景下的类型推断
2. 比较 let 和 const 的类型推断差异
3. 使用 as const 获得精确的字面量类型
4. 体验上下文类型推断的强大功能
5. 练习使用 typeof 和 keyof 操作符

---
最后更新: 2025-11-20