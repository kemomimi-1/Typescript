# React 函数组件的类型（TS 结合）

面向初学者的速学笔记：如何为 React 函数组件在 TypeScript 下进行类型标注，覆盖组件与属性类型、属性默认值、事件与事件对象。

## 1. 组件与属性类型

### 基本写法（推荐）
```typescript
import React from 'react'

type ButtonProps = {
  variant?: 'primary' | 'secondary'
  disabled?: boolean
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void
  children?: React.ReactNode
}

export function Button({ variant = 'primary', disabled, onClick, children }: ButtonProps) {
  return (
    <button type="button" data-variant={variant} disabled={disabled} onClick={onClick}>
      {children}
    </button>
  )
}
```

要点：
- 为 Props 定义独立类型。
- children 使用 `React.ReactNode`。
- 事件处理函数显式标注事件对象类型。
- 默认值通过函数参数默认值实现。

### 使用 `PropsWithChildren`
```typescript
import type { PropsWithChildren } from 'react'

type CardProps = PropsWithChildren<{ title: string }>

export function Card({ title, children }: CardProps) {
  return (
    <section>
      <h3>{title}</h3>
      {children}
    </section>
  )
}
```

### 关于 `React.FC`
```typescript
import type { FC } from 'react'

type LinkProps = { href: string; children?: React.ReactNode }

export const Link: FC<LinkProps> = ({ href, children }) => <a href={href}>{children}</a>
```

说明：`React.FC` 会自动包含 `children`，但在社区中更推荐为函数参数显式标注 Props 类型，便于控制 `children` 的存在与否、默认值等。

### 复用原生元素属性
```typescript
import type { ComponentProps } from 'react'

type NativeButtonProps = ComponentProps<'button'>

type MyButtonProps = {
  variant?: 'primary' | 'secondary'
} & Omit<NativeButtonProps, 'type' | 'onClick'> & {
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void
}

export function MyButton({ variant = 'primary', onClick, ...rest }: MyButtonProps) {
  return (
    <button type="button" data-variant={variant} onClick={onClick} {...rest} />
  )
}
```

## 2. 属性默认值

- 使用函数参数默认值实现默认行为：`{ size = 'md' }`。
- 与可选属性配合：`size?: 'sm' | 'md' | 'lg'`。
- 避免在函数组件上使用 `defaultProps`，直接在解构参数中给默认值即可。

示例：
```typescript
type AvatarProps = {
  size?: number
  src: string
}

export function Avatar({ size = 40, src }: AvatarProps) {
  return <img width={size} height={size} src={src} alt="avatar" />
}
```

## 3. 事件与事件对象类型

### React 合成事件体系
- 基类：`React.SyntheticEvent<T>`。
- 常见事件：
  - 鼠标：`React.MouseEvent<T>`
  - 键盘：`React.KeyboardEvent<T>`
  - 表单提交：`React.FormEvent<T>`
  - 输入变更：`React.ChangeEvent<T>`
  - 焦点：`React.FocusEvent<T>`

### 常用事件示例
```typescript
export function Form() {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
  }
  return <form onSubmit={handleSubmit}>...</form>
}
```

```typescript
export function TextInput() {
  const [value, setValue] = React.useState('')
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.currentTarget.value)
  }
  return <input value={value} onChange={handleChange} />
}
```

```typescript
export function IconButton({ onClick }: { onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void }) {
  return <button onClick={onClick}>+</button>
}
```

### 访问目标元素类型
- 使用泛型参数标注 DOM 元素类型：`MouseEvent<HTMLButtonElement>`、`ChangeEvent<HTMLInputElement>`。
- 建议优先使用 `currentTarget` 访问元素，以获得更稳定的类型。

### 键盘与组合键
```typescript
export function Hotkey() {
  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.ctrlKey && e.key === 'k') {
      e.preventDefault()
    }
  }
  return <input onKeyDown={onKeyDown} />
}
```

## 4. forwardRef 与事件结合
```typescript
import React, { forwardRef } from 'react'

type InputProps = {
  onEnter?: () => void
} & Omit<React.ComponentProps<'input'>, 'onKeyDown'>

export const TextField = forwardRef<HTMLInputElement, InputProps>(function TextField(
  { onEnter, ...rest },
  ref
) {
  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') onEnter?.()
  }
  return <input ref={ref} onKeyDown={onKeyDown} {...rest} />
})
```

## 5. 组合策略与最佳实践
- Props 独立建模，必要时用 `PropsWithChildren`。
- 事件处理函数显式标注事件类型，优先 `currentTarget`。
- 复用原生元素属性用 `ComponentProps<'tag'>`，必要时 `Omit` 以重写。
- 默认值通过函数参数默认值实现，避免函数组件的 `defaultProps`。
- 严格模式下尽量避免 `any`，使用联合类型与可选链。

## 6. 练习任务（巩固）
- 为一个 `Select` 组件建模：支持 `options`、`value`、`onChange(React.ChangeEvent<HTMLSelectElement>)`。
- 为一个 `Modal` 组件建模：`open`、`onClose(React.MouseEvent<HTMLButtonElement>)`、支持 `children`。
- 将 `Button` 扩展为原生属性超集，并重写 `type` 为常量 `"button"`。

掌握以上模式，你就能把 React 函数组件在 TS 下的类型写得既严谨又不繁琐。