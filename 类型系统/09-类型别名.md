# TypeScript 类型别名

## 概述
类型别名使用 `type` 关键字为类型创建一个新的名称，让代码更清晰、更易维护。

## 基本语法

### 创建类型别名
```typescript
type MyString = string;
type MyNumber = number;
```

### 使用类型别名
```typescript
type UserID = string;
type Age = number;

let userId: UserID = "user-123";
let age: Age = 25;
```

## 原始类型别名

### 基本类型别名
```typescript
type Name = string;
type Score = number;
type IsActive = boolean;

let name: Name = "Alice";
let score: Score = 100;
let isActive: IsActive = true;
```

### 使用场景
```typescript
// 提高代码可读性
function createUser(name: Name, age: Age): User {
  return { name, age };
}
```

## 联合类型别名

### 创建联合类型别名
```typescript
type ID = string | number;
type Status = "active" | "inactive" | "pending";
```

### 使用联合类型别名
```typescript
let userId: ID = "user-123";
userId = 456; // 也允许

let status: Status = "active";
// status = "unknown"; // 错误
```

## 对象类型别名

### 对象类型别名
```typescript
type Point = {
  x: number;
  y: number;
};

let point: Point = { x: 10, y: 20 };
```

### 嵌套对象别名
```typescript
type Address = {
  street: string;
  city: string;
  zipCode: string;
};

type User = {
  id: string;
  name: string;
  address: Address;
};
```

## 函数类型别名

### 函数类型别名
```typescript
type GreetFunction = (name: string) => string;

type MathOperation = (a: number, b: number) => number;
```

### 使用函数类型别名
```typescript
const greet: GreetFunction = (name) => `Hello, ${name}!`;

const add: MathOperation = (a, b) => a + b;
const multiply: MathOperation = (a, b) => a * b;
```

## 元组类型别名

### 元组类型别名
```typescript
type Coordinate = [number, number];
type PersonTuple = [string, number, boolean];
```

### 使用元组类型别名
```typescript
let point: Coordinate = [10, 20];
let person: PersonTuple = ["Alice", 25, true];
```

## 复杂类型组合

### 组合多种类型
```typescript
type User = {
  id: string;
  name: string;
  email?: string;
  roles: ("admin" | "user" | "guest")[];
  metadata: Record<string, any>;
};
```

### 使用复杂类型别名
```typescript
const user: User = {
  id: "1",
  name: "Alice",
  roles: ["admin", "user"],
  metadata: { createdAt: new Date() }
};
```

## 泛型类型别名

### 创建泛型类型别名
```typescript
type Response<T> = {
  data: T;
  status: number;
  message: string;
};

type Pair<T, U> = [T, U];
```

### 使用泛型类型别名
```typescript
let userResponse: Response<User> = {
  data: { id: "1", name: "Alice" },
  status: 200,
  message: "Success"
};

let keyValue: Pair<string, number> = ["age", 25];
```

## 类型别名与接口的区别

### 相似之处
```typescript
// 接口
interface Point {
  x: number;
  y: number;
}

// 类型别名
type Point = {
  x: number;
  y: number;
};
```

### 不同之处
```typescript
// 接口可以扩展
interface Point3D extends Point {
  z: number;
}

// 类型别名使用交叉类型
type Point3D = Point & { z: number };
```

## 类型别名的最佳实践

### 1. 使用有意义的名称
```typescript
// 好的命名
type UserID = string;
type EmailAddress = string;
type Timestamp = number;

// 避免
type Str = string;
type Num = number;
```

### 2. 保持别名简洁
```typescript
// 好的实践
type User = {
  id: string;
  name: string;
};

// 避免过度嵌套
type DeeplyNested = {
  user: {
    info: {
      personal: {
        name: string;
      };
    };
  };
};
```

### 3. 使用联合类型提高灵活性
```typescript
type Status = "pending" | "approved" | "rejected";
type ID = string | number;
```

### 4. 为复杂类型创建别名
```typescript
// 复杂的函数类型
type EventHandler = (event: MouseEvent) => void;

// 复杂的对象类型
type ApiResponse<T> = {
  data: T;
  error?: string;
  timestamp: number;
};
```

## 类型别名的实用技巧

### 1. 提取数组元素类型
```typescript
type Users = User[];
type UserElement = Users[number]; // User
```

### 2. 提取函数返回类型
```typescript
type GreetFunction = (name: string) => string;
type GreetReturn = ReturnType<GreetFunction>; // string
```

### 3. 提取函数参数类型
```typescript
type GreetFunction = (name: string, age: number) => string;
type GreetParams = Parameters<GreetFunction>; // [string, number]
```

### 4. 条件类型别名
```typescript
type NonNullable<T> = T extends null | undefined ? never : T;
type MaybeString = string | null | undefined;
type DefinitelyString = NonNullable<MaybeString>; // string
```

## 常见使用模式

### 1. 配置对象模式
```typescript
type Config = {
  apiUrl: string;
  timeout: number;
  retries: number;
  debug?: boolean;
};

const config: Config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
};
```

### 2. 状态管理模式
```typescript
type AppState = {
  user: User | null;
  isLoading: boolean;
  error: string | null;
};

const initialState: AppState = {
  user: null,
  isLoading: false,
  error: null
};
```

### 3. API 响应模式
```typescript
type ApiResponse<T> = 
  | { status: "success"; data: T }
  | { status: "error"; message: string };

function handleResponse<T>(response: ApiResponse<T>) {
  if (response.status === "success") {
    console.log("Data:", response.data);
  } else {
    console.error("Error:", response.message);
  }
}
```

## 类型别名的限制

### 1. 不能重复声明
```typescript
type Point = { x: number; y: number };
// type Point = { z: number }; // 错误：重复声明
```

### 2. 不能扩展（但可以使用交叉类型）
```typescript
type Point = { x: number; y: number };
type Point3D = Point & { z: number }; // 使用交叉类型
```

### 3. 性能考虑
对于非常复杂的类型，类型别名可能会影响编译性能。

## 最佳实践总结

1. **使用描述性名称**：让类型别名表达其用途
2. **保持简洁**：避免过度复杂的类型别名
3. **优先使用类型别名**：对于联合类型、元组类型和函数类型
4. **使用接口**：当需要声明合并或扩展时
5. **文档化**：为复杂的类型别名添加注释

## 练习建议

1. 为常见的业务概念创建类型别名
2. 练习使用泛型类型别名
3. 尝试创建复杂的类型组合
4. 比较类型别名和接口的使用场景
5. 体验类型别名的重构好处

---
最后更新: 2025-11-20