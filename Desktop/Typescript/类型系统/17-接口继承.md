# TypeScript 接口继承

## 概述
接口继承允许一个接口继承另一个或多个接口的成员，支持构建层次化的类型系统。接口继承提供了代码复用和类型约束的强大能力。

## 基本语法

### 单接口继承
```typescript
interface Animal {
  name: string;
  age: number;
}

interface Dog extends Animal {
  breed: string;
  bark(): void;
}
```

### 多接口继承
```typescript
interface CanSwim {
  swim(): void;
}

interface CanFly {
  fly(): void;
}

interface Duck extends CanSwim, CanFly {
  name: string;
  color: string;
}
```

## 继承的使用

### 实现继承接口
```typescript
const myDog: Dog = {
  name: "Buddy",
  age: 3,
  breed: "Golden Retriever",
  bark: () => console.log("Woof!")
};

const myDuck: Duck = {
  name: "Donald",
  color: "white",
  swim: () => console.log("Swimming"),
  fly: () => console.log("Flying")
};
```

### 函数参数类型
```typescript
function processAnimal(animal: Animal) {
  console.log(`Name: ${animal.name}, Age: ${animal.age}`);
}

function processDog(dog: Dog) {
  console.log(`Breed: ${dog.breed}`);
  dog.bark();
}

// Dog 可以传递给期望 Animal 的函数
processAnimal(myDog); // 正确
```

## 继承与属性重写

### 属性类型收紧
```typescript
interface Base {
  value: string | number;
}

interface Derived extends Base {
  value: string; // 收紧类型：string | number → string
}

const derived: Derived = { value: "hello" };
// derived.value = 123; // 错误：不能将 number 赋值给 string
```

### 方法重写
```typescript
interface Logger {
  log(message: string): void;
}

interface TimestampLogger extends Logger {
  log(message: string, timestamp: Date): void; // 重载方法
}

class MyLogger implements TimestampLogger {
  log(message: string, timestamp?: Date): void {
    const time = timestamp ? timestamp.toISOString() : new Date().toISOString();
    console.log(`[${time}] ${message}`);
  }
}
```

## 多层继承

### 继承链
```typescript
interface Entity {
  id: number;
  createdAt: Date;
}

interface User extends Entity {
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
  canDeleteUsers: boolean;
}

const admin: Admin = {
  id: 1,
  createdAt: new Date(),
  name: "Alice",
  email: "alice@example.com",
  permissions: ["read", "write", "delete"],
  canDeleteUsers: true
};
```

### 多层继承的方法
```typescript
interface Readable {
  read(): string;
}

interface Writable extends Readable {
  write(content: string): void;
}

interface ReadWrite extends Writable {
  close(): void;
}

class FileHandler implements ReadWrite {
  read(): string { return "content"; }
  write(content: string): void { console.log(content); }
  close(): void { console.log("File closed"); }
}
```

## 接口继承与类

### 类实现继承接口
```typescript
interface Animal {
  name: string;
  makeSound(): void;
}

interface Mammal extends Animal {
  hasFur: boolean;
  giveBirth(): void;
}

class Dog implements Mammal {
  name: string;
  hasFur: boolean;
  
  constructor(name: string) {
    this.name = name;
    this.hasFur = true;
  }
  
  makeSound(): void { console.log("Woof!"); }
  giveBirth(): void { console.log("Giving birth to puppies"); }
}
```

### 实现多个继承接口
```typescript
interface Printable {
  print(): void;
}

interface Scannable {
  scan(): void;
}

interface MultiFunction extends Printable, Scannable {
  copy(): void;
}

class Printer implements MultiFunction {
  print(): void { console.log("Printing"); }
  scan(): void { console.log("Scanning"); }
  copy(): void { console.log("Copying"); }
}
```

## 继承与泛型

### 泛型接口继承
```typescript
interface Repository<T> {
  get(id: number): T | undefined;
  save(entity: T): void;
}

interface UserRepository extends Repository<User> {
  findByEmail(email: string): User | undefined;
  deactivate(id: number): void;
}

class DatabaseUserRepository implements UserRepository {
  get(id: number): User | undefined { /* ... */ }
  save(entity: User): void { /* ... */ }
  findByEmail(email: string): User | undefined { /* ... */ }
  deactivate(id: number): void { /* ... */ }
}
```

### 约束泛型类型参数
```typescript
interface Comparable<T> {
  compare(other: T): number;
}

interface Sortable<T extends Comparable<T>> {
  sort(): void;
  getItems(): T[];
}

class NumberList implements Sortable<number> {
  private items: number[] = [];
  
  sort(): void { this.items.sort((a, b) => a - b); }
  getItems(): number[] { return this.items; }
  
  // number 需要实现 Comparable<number>
  // 但 TypeScript 内置类型有默认的比较行为
}
```

## 继承冲突处理

### 属性名冲突
```typescript
interface A {
  value: string;
}

interface B {
  value: number; // 冲突：string vs number
}

// interface C extends A, B {} // 错误：属性 'value' 的类型不兼容
```

### 方法重载冲突
```typescript
interface LoggerA {
  log(message: string): void;
}

interface LoggerB {
  log(message: string, level: number): void;
}

interface CombinedLogger extends LoggerA, LoggerB {
  // 合并为重载方法
  log(message: string, level?: number): void;
}
```

## 实用模式

### 1. 组合接口
```typescript
interface Identifiable {
  id: number;
}

interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

interface User extends Identifiable, Timestamped {
  name: string;
  email: string;
}
```

### 2. 接口隔离
```typescript
interface ReadOperations {
  findById(id: number): any;
  findAll(): any[];
}

interface WriteOperations {
  create(data: any): void;
  update(id: number, data: any): void;
  delete(id: number): void;
}

interface CrudRepository extends ReadOperations, WriteOperations {}
```

### 3. 装饰器模式
```typescript
interface Component {
  operation(): string;
}

interface Decorator extends Component {
  component: Component;
}

class ConcreteComponent implements Component {
  operation(): string { return "ConcreteComponent"; }
}

class ConcreteDecorator implements Decorator {
  constructor(public component: Component) {}
  
  operation(): string {
    return `Decorator(${this.component.operation()})`;
  }
}
```

## 最佳实践

### 1. 保持接口单一职责
```typescript
// 好的实践：每个接口只关注一个方面
interface Named {
  name: string;
}

interface Aged {
  age: number;
}

interface Person extends Named, Aged {
  email: string;
}
```

### 2. 使用接口组合而不是深层继承
```typescript
// 避免过深的继承层次
interface Animal { /* ... */ }
interface Mammal extends Animal { /* ... */ }
interface Dog extends Mammal { /* ... */ }
interface Labrador extends Dog { /* ... */ } // 太深了！

// 更好的方式：使用组合
interface Animal { /* ... */ }
interface Breed {
  breed: string;
  characteristics: string[];
}

interface Dog extends Animal, Breed { /* ... */ }
```

### 3. 为继承接口提供文档
```typescript
/**
 * 基础实体接口
 * @property id - 唯一标识符
 * @property createdAt - 创建时间
 */
interface Entity {
  id: number;
  createdAt: Date;
}

/**
 * 用户接口，继承自 Entity
 * @extends Entity
 */
interface User extends Entity {
  name: string;
  email: string;
}
```

### 4. 考虑使用类型别名进行组合
```typescript
// 有时候类型别名更简洁
type Named = { name: string; };
type Aged = { age: number; };
type Person = Named & Aged & { email: string; };
```

## 常见错误

### 1. 循环继承
```typescript
interface A extends B { /* ... */ }
interface B extends A { /* ... */ } // 错误：循环继承
```

### 2. 忽略必需属性
```typescript
interface Base {
  required: string;
}

interface Derived extends Base {
  // 忘记实现 required 属性
  additional: number;
}

const derived: Derived = { additional: 123 }; // 错误：缺少 required
```

### 3. 类型冲突
```typescript
interface A {
  value: string;
}

interface B {
  value: number;
}

// interface C extends A, B {} // 错误：属性 'value' 的类型不兼容
```

## 练习建议

1. 创建多层次的接口继承结构
2. 练习接口组合和多重继承
3. 实现继承接口的类
4. 处理继承中的类型冲突
5. 比较接口继承和类型别名交叉类型的区别

---
最后更新: 2025-11-20