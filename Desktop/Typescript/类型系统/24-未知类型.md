# 未知类型 (unknown type)

## 概念定义
未知类型是 TypeScript 中的一种安全类型，它表示值的类型未知，在使用前必须进行类型检查或类型断言。

## 语法示例
```typescript
// 基本用法
let value: unknown = "hello";
value = 42;
value = true;

// 直接使用会报错
// value.toUpperCase(); // 错误: 'value' 的类型为 'unknown'

// 需要类型检查后才能使用
if (typeof value === "string") {
  console.log(value.toUpperCase()); // 现在安全了
}
```

## 使用场景

### 1. 处理外部数据
```typescript
// 从API获取的数据
async function fetchUserData(): Promise<unknown> {
  const response = await fetch('/api/user');
  return response.json();
}

// 安全地处理数据
const userData = await fetchUserData();
if (userData && typeof userData === "object" && "name" in userData) {
  console.log(userData.name);
}
```

### 2. 类型安全的动态处理
```typescript
function processUnknown(input: unknown): string {
  if (typeof input === "string") {
    return input;
  } else if (typeof input === "number") {
    return input.toString();
  } else if (Array.isArray(input)) {
    return input.join(", ");
  }
  return "Unknown type";
}
```

### 3. 替代 any 类型
```typescript
// 使用 unknown 代替 any 更安全
function parseConfig(config: unknown): Config {
  // 必须进行类型检查
  if (isConfig(config)) {
    return config;
  }
  throw new Error("Invalid config");
}

function isConfig(obj: unknown): obj is Config {
  return (
    obj !== null &&
    typeof obj === "object" &&
    "theme" in obj &&
    typeof obj.theme === "string"
  );
}
```

## 类型特性

### 1. 类型收缩
```typescript
function handleValue(value: unknown) {
  // 类型守卫收缩类型
  if (value === null || value === undefined) {
    return; // value 现在是 null | undefined
  }
  
  if (typeof value === "string") {
    console.log(value.length); // value 现在是 string
  }
  
  if (Array.isArray(value)) {
    console.log(value.length); // value 现在是 any[]
  }
}
```

### 2. 与 any 的区别
```typescript
let anyValue: any = "hello";
let unknownValue: unknown = "hello";

// any 类型 - 不安全的
anyValue.toFixed(); // 编译时通过，运行时可能出错

// unknown 类型 - 安全的
// unknownValue.toFixed(); // 编译时报错: 对象的类型为 "unknown"
```

## 最佳实践

### 1. 自定义类型守卫
```typescript
// 创建自定义类型守卫
function isUser(obj: unknown): obj is User {
  return (
    obj !== null &&
    typeof obj === "object" &&
    "id" in obj && typeof obj.id === "number" &&
    "name" in obj && typeof obj.name === "string" &&
    "email" in obj && (obj.email === null || typeof obj.email === "string")
  );
}

// 使用类型守卫
const data: unknown = await fetchData();
if (isUser(data)) {
  console.log(data.name); // data 现在是 User 类型
}
```

### 2. 联合类型与 unknown
```typescript
// unknown 与其他类型的联合
type Result = unknown | string | number;

function processResult(result: Result) {
  if (result === null || result === undefined) {
    return "nullish";
  }
  
  if (typeof result === "string") {
    return result.toUpperCase();
  }
  
  if (typeof result === "number") {
    return result.toFixed(2);
  }
  
  return "unknown";
}
```

### 3. 错误处理模式
```typescript
// 安全的错误处理
function safeParseJSON(json: string): unknown {
  try {
    return JSON.parse(json);
  } catch {
    return null;
  }
}

const result = safeParseJSON('{"name": "Alice"}');
if (result && typeof result === "object" && "name" in result) {
  console.log(result.name);
}
```

## 实用技巧

### 1. 渐进式类型验证
```typescript
// 逐步验证复杂对象
function validateConfig(config: unknown): Config {
  if (!config || typeof config !== "object") {
    throw new Error("Config must be an object");
  }
  
  const cfg = config as Record<string, unknown>;
  
  if (typeof cfg.port !== "number" || cfg.port < 1 || cfg.port > 65535) {
    throw new Error("Invalid port number");
  }
  
  if (typeof cfg.hostname !== "string") {
    throw new Error("Hostname must be a string");
  }
  
  return config as Config;
}
```

### 2. 模板方法模式
```typescript
// 创建可重用的验证逻辑
abstract class Validator<T> {
  abstract validate(data: unknown): data is T;
  
  ensureValid(data: unknown): T {
    if (this.validate(data)) {
      return data;
    }
    throw new Error("Validation failed");
  }
}

class UserValidator extends Validator<User> {
  validate(data: unknown): data is User {
    return isUser(data);
  }
}
```

### 3. 与泛型结合
```typescript
// 泛型函数处理 unknown
function safeCast<T>(value: unknown, validator: (val: unknown) => val is T): T {
  if (validator(value)) {
    return value;
  }
  throw new Error("Type cast failed");
}

// 使用示例
const user = safeCast(await fetchData(), isUser);
```

## 常见错误模式

### 1. 过度使用类型断言
```typescript
// 不良实践 - 绕过类型检查
const data = unknownValue as User; // 可能不安全

// 良好实践 - 使用类型守卫
if (isUser(unknownValue)) {
  const data = unknownValue; // 安全的
}
```

### 2. 忽略类型检查
```typescript
// 危险的做法
function dangerousProcess(input: unknown) {
  // 没有类型检查直接使用
  const obj = input as any;
  console.log(obj.name); // 运行时可能出错
}

// 安全的做法
function safeProcess(input: unknown) {
  if (input && typeof input === "object" && "name" in input) {
    console.log(input.name);
  }
}
```

## 性能考虑

### 1. 类型检查开销
```typescript
// 复杂的类型检查可能影响性能
function complexValidation(obj: unknown): obj is ComplexType {
  // 多个属性检查...
  return true;
}

// 考虑缓存验证结果或使用更简单的检查
```

### 2. 编译时优化
```typescript
// TypeScript 编译器会优化类型守卫
function optimizedCheck(value: unknown) {
  if (typeof value === "string") {
    // 编译器知道这里 value 是 string
    return value.length;
  }
  return 0;
}
```

## 总结
未知类型提供了类型安全的动态编程能力：

✅ **优点**:
- 比 any 类型更安全
- 强制进行类型检查
- 适合处理外部数据
- 支持渐进式类型验证

❌ **缺点**:
- 需要额外的类型检查代码
- 可能增加代码复杂度
- 复杂的验证逻辑可能影响性能

**适用场景**:
- 处理JSON解析结果
- 接收第三方库数据
- 实现类型安全的动态逻辑
- 迁移过程中的类型安全

---
**示例文件**: [examples/24-unknown-type.ts](../examples/24-unknown-type.ts)