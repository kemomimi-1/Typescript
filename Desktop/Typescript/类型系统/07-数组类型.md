# TypeScript 数组类型

## 概述
数组是存储多个相同类型值的集合。TypeScript 提供了两种声明数组类型的方式。

## 两种声明语法

### 1. 类型[] 语法（推荐）
```typescript
let numbers: number[] = [1, 2, 3];
let strings: string[] = ["a", "b", "c"];
```

### 2. Array<类型> 语法（泛型语法）
```typescript
let numbers: Array<number> = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];
```

## 基本数组操作

### 创建数组
```typescript
let empty: number[] = [];                    // 空数组
let primes: number[] = [2, 3, 5, 7, 11];     // 数字数组
let names: string[] = ["Alice", "Bob", "Charlie"]; // 字符串数组
```

### 访问元素
```typescript
let numbers: number[] = [10, 20, 30];
let first: number = numbers[0];  // 10
let second: number = numbers[1]; // 20
```

### 修改元素
```typescript
let scores: number[] = [85, 90, 78];
scores[1] = 95; // 修改第二个元素
console.log(scores); // [85, 95, 78]
```

## 数组方法类型安全

### push 和 pop
```typescript
let stack: number[] = [];
stack.push(1);    // 添加元素
stack.push(2);
let last = stack.pop(); // 移除并返回最后一个元素: 2
```

### map 方法
```typescript
let numbers: number[] = [1, 2, 3];
let doubled: number[] = numbers.map(n => n * 2); // [2, 4, 6]
```

### filter 方法
```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
let evens: number[] = numbers.filter(n => n % 2 === 0); // [2, 4]
```

### reduce 方法
```typescript
let numbers: number[] = [1, 2, 3, 4];
let sum: number = numbers.reduce((acc, n) => acc + n, 0); // 10
```

## 只读数组

### ReadonlyArray 类型
```typescript
let numbers: ReadonlyArray<number> = [1, 2, 3];
// numbers.push(4); // 错误：ReadonlyArray 没有 push 方法
// numbers[0] = 10; // 错误：索引签名仅允许读取
```

### readonly 修饰符
```typescript
let numbers: readonly number[] = [1, 2, 3];
// numbers.push(4); // 错误
```

## 多维数组

### 二维数组
```typescript
let matrix: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

let value: number = matrix[1][2]; // 6
```

### 三维数组
```typescript
let cube: number[][][] = [
  [[1, 2], [3, 4]],
  [[5, 6], [7, 8]]
];
```

## 数组类型推断

### 自动类型推断
```typescript
let numbers = [1, 2, 3];          // 推断为 number[]
let mixed = [1, "hello", true];   // 推断为 (number | string | boolean)[]
```

### 空数组的类型推断
```typescript
let empty = []; // 推断为 any[]
empty.push(1);
empty.push("hello"); // 允许，因为类型是 any[]
```

### 明确空数组类型
```typescript
let empty: number[] = []; // 明确类型
empty.push(1);
// empty.push("hello"); // 错误：不能将类型"string"分配给类型"number"
```

## 数组与联合类型

### 联合类型数组
```typescript
let mixed: (number | string)[] = [1, "hello", 2, "world"];
```

### 类型守卫
```typescript
function processArray(arr: (number | string)[]) {
  arr.forEach(item => {
    if (typeof item === "number") {
      console.log(`Number: ${item}`);
    } else {
      console.log(`String: ${item}`);
    }
  });
}
```

## 数组解构

### 基本解构
```typescript
let numbers: number[] = [1, 2, 3];
let [first, second, third] = numbers;
console.log(first, second, third); // 1, 2, 3
```

### 带类型注解的解构
```typescript
let numbers: number[] = [1, 2, 3];
let [a, b]: [number, number] = numbers; // 前两个元素
```

### 剩余元素
```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
let [first, second, ...rest] = numbers;
console.log(rest); // [3, 4, 5]
```

## 数组类型兼容性

### 协变（Covariance）
```typescript
let numbers: number[] = [1, 2, 3];
let values: (number | string)[] = numbers; // 允许
```

### 逆变（Contravariance）
```typescript
let values: (number | string)[] = [1, "hello"];
// let numbers: number[] = values; // 错误
```

## 实用类型操作

### 数组元素类型提取
```typescript
type NumberArray = number[];
type ElementType = NumberArray[number]; // number
```

### 只读数组元素类型
```typescript
type ReadonlyNumbers = readonly number[];
type ReadonlyElement = ReadonlyNumbers[number]; // number
```

## 最佳实践

### 1. 使用类型[] 语法
```typescript
// 推荐
let numbers: number[] = [1, 2, 3];

// 不推荐（除非需要泛型约束）
let numbers: Array<number> = [1, 2, 3];
```

### 2. 明确空数组类型
```typescript
// 避免
let arr = [];

// 推荐
let arr: number[] = [];
```

### 3. 使用 readonly 保护数组
```typescript
function processData(data: readonly number[]) {
  // data 不能被修改
  return data.map(x => x * 2);
}
```

### 4. 利用类型推断
```typescript
// 让 TypeScript 推断类型
let numbers = [1, 2, 3]; // 推断为 number[]
```

## 常见错误

### 1. 类型不匹配
```typescript
let numbers: number[] = [1, 2, 3];
// numbers.push("hello"); // 错误
```

### 2. 越界访问
```typescript
let arr: number[] = [1, 2, 3];
let value = arr[10]; // undefined，但不会编译错误
```

### 3. 混淆数组和元组
```typescript
// 数组 - 长度可变，元素类型相同
let arr: number[] = [1, 2, 3];
arr.push(4); // 允许

// 元组 - 长度固定，元素类型可以不同
let tuple: [number, string] = [1, "hello"];
// tuple.push(2); // 运行时允许，但类型不安全
```

## 练习建议

1. 创建不同类型的数组并添加类型注解
2. 练习使用数组方法（map、filter、reduce）
3. 尝试使用只读数组保护数据
4. 练习数组解构和剩余参数
5. 体验类型推断和显式注解的区别

---
最后更新: 2025-11-20