# 常量断言 (Const Assertions)

## 概念定义
常量断言是 TypeScript 3.4 引入的特性，它允许我们告诉编译器将表达式视为字面量类型而不是更宽泛的类型，从而获得更精确的类型推断。

## 语法示例
```typescript
// 基本常量断言语法
const point = { x: 10, y: 20 } as const;

// 数组常量断言
const numbers = [1, 2, 3] as const;

// 元组常量断言
const tuple = ["hello", 42] as const;

// 使用示例
const config = {
  theme: "dark",
  fontSize: 14,
  language: "zh-CN"
} as const;

// 类型推断结果:
// {
//   readonly theme: "dark";
//   readonly fontSize: 14;
//   readonly language: "zh-CN";
// }
```

## 使用场景

### 1. 配置对象
```typescript
// 应用配置
const APP_CONFIG = {
  name: "My App",
  version: "1.0.0",
  environment: "production",
  features: {
    darkMode: true,
    notifications: false,
    analytics: true
  }
} as const;

// 类型安全访问
function getFeatureStatus(feature: keyof typeof APP_CONFIG.features): boolean {
  return APP_CONFIG.features[feature];
}

// 编译时检查
getFeatureStatus("darkMode"); // true
getFeatureStatus("notifications"); // false
// getFeatureStatus("invalid"); // 错误: 参数类型不对
```

### 2. 枚举替代
```typescript
// 使用常量断言替代枚举
const UserRole = {
  ADMIN: "admin",
  USER: "user",
  GUEST: "guest"
} as const;

type UserRole = typeof UserRole[keyof typeof UserRole];
// 等效于: "admin" | "user" | "guest"

// 使用示例
interface User {
  id: number;
  name: string;
  role: UserRole;
}

function canEditContent(user: User): boolean {
  return user.role === UserRole.ADMIN;
}

// 比枚举更轻量，保持字符串值
```

### 3. 路由定义
```typescript
// 类型安全的路由配置
const ROUTES = {
  HOME: "/",
  ABOUT: "/about",
  USERS: "/users",
  USER_DETAIL: (id: number) => `/users/${id}`,
  SETTINGS: "/settings"
} as const;

type RouteKey = keyof typeof ROUTES;

type RouteParams<T extends RouteKey> = 
  typeof ROUTES[T] extends (arg: infer P) => string ? P : never;

// 使用示例
function navigateTo<T extends RouteKey>(route: T, params: RouteParams<T>): void {
  const path = typeof ROUTES[route] === "function" 
    ? (ROUTES[route] as Function)(params)
    : ROUTES[route];
  console.log("Navigating to:", path);
}

navigateTo("HOME"); // 正确
navigateTo("USER_DETAIL", 123); // 正确
// navigateTo("USER_DETAIL"); // 错误: 缺少参数
// navigateTo("ABOUT", "extra"); // 错误: 不需要参数
```

## 类型特性

### 1. 字面量类型推断
```typescript
// 没有常量断言
const withoutConst = { theme: "dark", size: 14 };
// 类型: { theme: string; size: number; }

// 有常量断言
const withConst = { theme: "dark", size: 14 } as const;
// 类型: { readonly theme: "dark"; readonly size: 14; }

// 数组示例
const numbers = [1, 2, 3]; // number[]
const constNumbers = [1, 2, 3] as const; // readonly [1, 2, 3]
```

### 2. 只读属性
```typescript
// 常量断言使所有属性变为只读
const config = {
  theme: "dark",
  sizes: [12, 14, 16],
  colors: { primary: "#000", secondary: "#fff" }
} as const;

// 所有层级都是只读的
// config.theme = "light"; // 错误: 无法分配到 "theme"，因为它是只读属性
// config.sizes.push(18); // 错误: 属性 'push' 在类型 'readonly [12, 14, 16]' 上不存在
// config.colors.primary = "#333"; // 错误: 无法分配到 "primary"，因为它是只读属性
```

### 3. 深度只读
```typescript
// 常量断言是深度只读的
const deepConfig = {
  database: {
    host: "localhost",
    port: 5432,
    credentials: {
      username: "admin",
      password: "secret"
    }
  },
  server: {
    port: 3000,
    cors: {
      origins: ["http://localhost:3000", "https://example.com"]
    }
  }
} as const;

// 所有嵌套层级都是只读的
// deepConfig.database.port = 3306; // 错误
// deepConfig.database.credentials.username = "root"; // 错误
// deepConfig.server.cors.origins.push("https://test.com"); // 错误
```

## 最佳实践

### 1. 配置对象模式
```typescript
// 使用常量断言创建不可变配置
const APP_SETTINGS = {
  // 应用信息
  app: {
    name: "My Application",
    version: "1.0.0",
    environment: process.env.NODE_ENV || "development"
  } as const,
  
  // API 配置
  api: {
    baseURL: process.env.API_URL || "https://api.example.com",
    timeout: 10000,
    retries: 3
  } as const,
  
  // 功能开关
  features: {
    darkMode: true,
    analytics: false,
    experimental: ["newDashboard", "advancedSearch"] as const
  } as const
} as const;

// 类型安全访问
type FeatureKey = keyof typeof APP_SETTINGS.features;
type ExperimentalFeature = typeof APP_SETTINGS.features.experimental[number];
```

### 2. 主题系统
```typescript
// 类型安全的主题系统
const THEMES = {
  light: {
    colors: {
      primary: "#ffffff",
      secondary: "#f0f0f0",
      text: "#333333",
      accent: "#007acc"
    },
    spacing: {
      small: 8,
      medium: 16,
      large: 24
    }
  } as const,
  
  dark: {
    colors: {
      primary: "#1a1a1a",
      secondary: "#2d2d2d",
      text: "#ffffff",
      accent: "#0099ff"
    },
    spacing: {
      small: 8,
      medium: 16,
      large: 24
    }
  } as const
} as const;

type ThemeName = keyof typeof THEMES;
type ColorKey = keyof typeof THEMES.light.colors;
type SpacingKey = keyof typeof THEMES.light.spacing;

function getThemeColor(theme: ThemeName, color: ColorKey): string {
  return THEMES[theme].colors[color];
}
```

### 3. 错误代码系统
```typescript
// 类型安全的错误代码
const ERROR_CODES = {
  // 认证错误
  AUTH: {
    INVALID_CREDENTIALS: "auth/invalid-credentials",
    TOKEN_EXPIRED: "auth/token-expired",
    PERMISSION_DENIED: "auth/permission-denied"
  } as const,
  
  // 数据库错误
  DB: {
    CONNECTION_FAILED: "db/connection-failed",
    QUERY_ERROR: "db/query-error",
    RECORD_NOT_FOUND: "db/record-not-found"
  } as const,
  
  // 网络错误
  NETWORK: {
    TIMEOUT: "network/timeout",
    OFFLINE: "network/offline",
    SERVER_ERROR: "network/server-error"
  } as const
} as const;

type ErrorCategory = keyof typeof ERROR_CODES;
type AuthError = typeof ERROR_CODES.AUTH[keyof typeof ERROR_CODES.AUTH];
type DbError = typeof ERROR_CODES.DB[keyof typeof ERROR_CODES.DB];
type NetworkError = typeof ERROR_CODES.NETWORK[keyof typeof ERROR_CODES.NETWORK];

type AppError = AuthError | DbError | NetworkError;

function handleError(error: AppError): void {
  switch (error) {
    case ERROR_CODES.AUTH.INVALID_CREDENTIALS:
      console.log("Invalid credentials");
      break;
    case ERROR_CODES.DB.RECORD_NOT_FOUND:
      console.log("Record not found");
      break;
    // ... 其他错误处理
  }
}
```

## 与枚举比较

### 1. 枚举方式
```typescript
// 传统枚举
enum UserRole {
  ADMIN = "admin",
  USER = "user",
  GUEST = "guest"
}

// 使用枚举
const user: { role: UserRole } = { role: UserRole.ADMIN };

// 运行时值
console.log(UserRole.ADMIN); // "admin"
```

### 2. 常量断言方式
```typescript
// 常量断言方式
const UserRole = {
  ADMIN: "admin",
  USER: "user",
  GUEST: "guest"
} as const;

type UserRole = typeof UserRole[keyof typeof UserRole];

// 使用方式相同
const user: { role: UserRole } = { role: UserRole.ADMIN };

// 运行时值
console.log(UserRole.ADMIN); // "admin"
```

### 3. 优缺点比较
```typescript
// 枚举优点:
// - 更好的命名空间
// - 反向映射支持
// - 更传统的做法

// 常量断言优点:
// - 更轻量
// - 保持字符串值
// - 更好的树摇优化
// - 更灵活的结构
```

## 实用技巧

### 1. 组合使用
```typescript
// 常量断言与其他类型特性组合
const PAGINATION = {
  DEFAULT_PAGE: 1,
  DEFAULT_LIMIT: 20,
  MAX_LIMIT: 100
} as const;

type PaginationParams = {
  page?: number;
  limit?: number;
};

function getPaginationParams(params: PaginationParams) {
  return {
    page: params.page ?? PAGINATION.DEFAULT_PAGE,
    limit: Math.min(params.limit ?? PAGINATION.DEFAULT_LIMIT, PAGINATION.MAX_LIMIT)
  };
}
```

### 2. 环境变量处理
```typescript
// 类型安全的环境变量
const ENV = {
  NODE_ENV: process.env.NODE_ENV || "development",
  API_URL: process.env.API_URL || "http://localhost:3000",
  DEBUG: process.env.DEBUG === "true",
  PORT: parseInt(process.env.PORT || "3000")
} as const;

type Environment = typeof ENV;

// 运行时访问
if (ENV.DEBUG) {
  console.log("Debug mode enabled");
}
```

### 3. 特性标志
```typescript
// 类型安全的特性标志
const FEATURE_FLAGS = {
  ENABLE_NEW_UI: true,
  ENABLE_ANALYTICS: false,
  ENABLE_EXPERIMENTAL: ["featureA", "featureB"] as const,
  MAX_USERS: 1000
} as const;

type ExperimentalFeature = typeof FEATURE_FLAGS.ENABLE_EXPERIMENTAL[number];

function isFeatureEnabled(feature: ExperimentalFeature): boolean {
  return FEATURE_FLAGS.ENABLE_EXPERIMENTAL.includes(feature);
}
```

## 常见错误

### 1. 过度使用
```typescript
// 不要为所有对象都使用常量断言
// 不良实践
const user = { name: "Alice", age: 30 } as const; // 不必要的

// 良好实践 - 只在需要不可变性和字面量类型时使用
const CONFIG = { theme: "dark", debug: true } as const; // 合适的
```

### 2. 可变性冲突
```typescript
// 常量断言与可变操作冲突
const config = { items: [1, 2, 3] } as const;

// config.items.push(4); // 错误: 属性 'push' 在类型 'readonly [1, 2, 3]' 上不存在

// 解决方案: 需要可变性时不要使用常量断言
const mutableConfig = { items: [1, 2, 3] };
mutableConfig.items.push(4); // 正确
```

### 3. 类型扩展问题
```typescript
// 常量断言可能限制类型扩展
const strictConfig = { theme: "dark" } as const;

// 无法添加新属性
// const extendedConfig = { ...strictConfig, fontSize: 14 }; // 类型错误

// 解决方案: 使用类型断言或更宽松的类型
const extendedConfig = { ...strictConfig, fontSize: 14 } as const;
// 或者
interface Config { theme: string; fontSize?: number; }
const config: Config = { theme: "dark", fontSize: 14 };
```

## 性能考虑

### 1. 编译时特性
```typescript
// 常量断言是编译时特性，不影响运行时性能
const config = { theme: "dark" } as const;

// 编译后的代码:
// var config = { theme: "dark" };
// 没有额外的运行时开销
```

### 2. 类型检查性能
```typescript
// 复杂的常量断言可能增加编译时间
// 但对于大多数应用影响可以忽略

const complexConfig = {
  // 大量嵌套属性...
} as const;

// 简单的常量断言几乎没有性能影响
const simpleConfig = { enabled: true } as const;
```

### 3. 内存使用
```typescript
// 常量断言不影响运行时内存使用
// 它只影响类型系统的内存使用

// 类型系统内存使用通常很小
// 即使对于大型配置对象
```

## 总结
常量断言提供了强大的类型安全特性：

✅ **优点**:
- 精确的字面量类型推断
- 深度只读属性
- 更好的类型安全性
- 编译时不可变性保证
- 轻量的枚举替代方案

❌ **缺点**:
- 可能限制类型扩展
- 与可变操作冲突
- 需要谨慎使用避免过度

**最佳实践**:
- 用于配置对象和常量
- 替代简单的枚举
- 创建不可变的运行时值
- 注意与可变操作的兼容性
- 避免不必要的使用

---
**示例文件**: [examples/31-const-assertions.ts](../examples/31-const-assertions.ts)