# 37. 类型兼容性 (Type Compatibility)

## 概念定义

**类型兼容性**是 TypeScript 类型系统的核心概念，它基于结构化类型（鸭子类型）而非名义类型。TypeScript 检查类型是否兼容时，关注的是类型的结构而非类型的名称。如果两个类型具有相同的结构，它们就是兼容的。

## 语法示例

### 基础类型兼容性
```typescript
// 结构类型兼容
interface Person {
  name: string;
  age: number;
}

interface Employee {
  name: string;
  age: number;
  department: string;
}

let person: Person = { name: "Alice", age: 30 };
let employee: Employee = { name: "Bob", age: 25, department: "IT" };

// Employee 可以赋值给 Person（包含 Person 的所有属性）
person = employee; // ✅ 兼容

// Person 不能赋值给 Employee（缺少 department 属性）
// employee = person; // ❌ 不兼容
```

### 函数类型兼容性
```typescript
// 函数参数兼容性
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // ✅ 兼容 - y 的参数列表包含 x 的参数列表
// x = y; // ❌ 不兼容 - x 的参数列表不包含 y 的参数列表

// 函数返回值兼容性
let a = () => ({ name: "Alice" });
let b = () => ({ name: "Bob", age: 30 });

a = b; // ✅ 兼容 - b 的返回值包含 a 的返回值所需属性
// b = a; // ❌ 不兼容 - a 的返回值缺少 age 属性
```

### 可选属性和多余属性
```typescript
interface Config {
  width: number;
  height: number;
  title?: string;
}

// 多余属性检查（对象字面量）
let config: Config = {
  width: 100,
  height: 200,
  title: "My App",
  // color: "red" // ❌ 错误：对象字面量只能包含已知属性
};

// 通过类型断言绕过检查
let config2: Config = {
  width: 100,
  height: 200,
  title: "My App",
  color: "red"
} as Config; // ✅ 使用类型断言

// 或者使用索引签名
interface FlexibleConfig {
  width: number;
  height: number;
  title?: string;
  [prop: string]: any; // 允许任意额外属性
}
```

## 使用场景

### 1. 组件属性兼容
```typescript
// React 组件属性兼容性
interface BaseProps {
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
}

interface ButtonProps extends BaseProps {
  onClick?: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

interface IconButtonProps extends ButtonProps {
  icon: string;
  size?: 'small' | 'medium' | 'large';
}

// 高阶组件中的类型兼容
function withLoading<P extends BaseProps>(Component: React.ComponentType<P>) {
  return function WithLoading(props: P & { isLoading?: boolean }) {
    if (props.isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...props} />;
  };
}

// 使用
const Button: React.FC<ButtonProps> = (props) => <button {...props} />;
const LoadingButton = withLoading(Button);

// LoadingButton 现在接受 ButtonProps + isLoading
<LoadingButton 
  onClick={() => console.log('clicked')}
  isLoading={true}
  variant="primary"
/>
```

### 2. API 响应处理
```typescript
// API 响应类型兼容性
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

interface DetailedUser extends User {
  age: number;
  address?: string;
  phone?: string;
}

// 处理不同详细程度的用户数据
async function fetchUser(endpoint: string): Promise<User> {
  const response = await fetch(endpoint);
  const result: ApiResponse<DetailedUser> = await response.json();
  
  // DetailedUser 可以赋值给 User（包含 User 的所有属性）
  return result.data; // ✅ 兼容
}

// 使用基础用户数据的地方可以接受详细用户数据
function displayUser(user: User) {
  console.log(`User: ${user.name} (${user.email})`);
}

// 可以传递 DetailedUser
const detailedUser: DetailedUser = {
  id: 1, 
  name: "Alice", 
  email: "alice@example.com", 
  age: 30
};

displayUser(detailedUser); // ✅ 兼容
```

### 3. 配置对象处理
```typescript
// 配置对象的类型兼容性
interface BaseConfig {
  apiUrl: string;
  timeout: number;
  retryAttempts?: number;
}

interface FullConfig extends BaseConfig {
  cacheEnabled: boolean;
  logLevel: 'debug' | 'info' | 'warn' | 'error';
  features: {
    analytics: boolean;
    notifications: boolean;
  };
}

// 接受基础配置的函数
function initializeApp(config: BaseConfig) {
  console.log(`Initializing with API: ${config.apiUrl}`);
  if (config.retryAttempts) {
    console.log(`Retry attempts: ${config.retryAttempts}`);
  }
}

// 可以传递完整配置
const fullConfig: FullConfig = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  cacheEnabled: true,
  logLevel: "info",
  features: {
    analytics: true,
    notifications: false
  }
};

initializeApp(fullConfig); // ✅ 兼容

// 配置合并函数
function mergeConfigs(base: BaseConfig, overrides: Partial<FullConfig>): FullConfig {
  return {
    apiUrl: "https://default.api",
    timeout: 3000,
    cacheEnabled: false,
    logLevel: "warn",
    features: {
      analytics: false,
      notifications: false
    },
    ...base,
    ...overrides
  };
}

// 使用类型兼容性进行配置合并
const merged = mergeConfigs(
  { apiUrl: "https://custom.api", timeout: 1000 },
  { logLevel: "debug", features: { analytics: true } }
);
```

## 注意事项

###  freshness（对象字面量检查）
```typescript
interface Point {
  x: number;
  y: number;
}

function printPoint(point: Point) {
  console.log(`x: ${point.x}, y: ${point.y}`);
}

// 对象字面量会进行严格检查
printPoint({ x: 1, y: 2 }); // ✅ 正确
// printPoint({ x: 1, y: 2, z: 3 }); // ❌ 错误：多余属性

// 变量赋值不会进行严格检查
const point = { x: 1, y: 2, z: 3 };
printPoint(point); // ✅ 正确：变量赋值
```

### 函数参数双向协变
```typescript
// 函数参数是双向协变的（出于实际考虑）
interface Event {
  timestamp: number;
}

interface MouseEvent extends Event {
  x: number;
  y: number;
}

interface KeyboardEvent extends Event {
  key: string;
}

// 事件处理函数
function handleEvent(event: Event) {
  console.log(`Event at ${event.timestamp}`);
}

// 可以接受更具体的参数类型
const handleMouse: (event: MouseEvent) => void = handleEvent; // ✅ 兼容
const handleKeyboard: (event: KeyboardEvent) => void = handleEvent; // ✅ 兼容
```

### 最佳实践
```typescript
// 1. 使用接口扩展而不是重复定义
interface Base { a: string; }
interface Extended extends Base { b: number; }

// 2. 使用类型查询确保兼容性
function ensureCompatibility<T extends Base>(obj: T): T {
  return obj;
}

// 3. 使用泛型约束
function processData<T extends { id: number }>(data: T[]) {
  return data.map(item => ({ ...item, processed: true }));
}

// 4. 避免过度使用 any，使用 unknown 或类型守卫
function safeProcess(input: unknown) {
  if (typeof input === 'string') {
    return input.length; // 现在 input 是 string
  }
  return 0;
}
```

## 示例代码位置

相关示例代码请查看：`examples/37-type-compatibility.ts`

---

**上一节**: [36-模块](./36-模块.md)  
**下一节**: [38-类型体操](./38-类型体操.md)  
**返回目录**: [高级特性目录](../高级特性/)