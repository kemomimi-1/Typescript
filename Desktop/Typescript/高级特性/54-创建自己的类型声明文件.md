# 创建自己的类型声明文件（从零开始）

当第三方库没有现成类型，或你在写纯 JavaScript 但希望使用 TypeScript 的类型检查时，可以自己编写 `.d.ts`（声明文件）。它只描述类型结构，不包含任何运行时代码。

## 核心概念速览
- 声明文件：以 `.d.ts` 结尾，只写类型与签名。
- 全局声明：为 `window`、`global` 等添加全局类型。
- 模块声明：为 `import 'xxx'` 的模块提供类型。
- 增量声明：为已有模块“补充”类型（模块增强）。

## 放置位置与配置
- 在项目中新建 `types/` 目录，放置你的 `.d.ts` 文件。
- 在 `tsconfig.json` 中让编译器找到这些类型：

```json
{
  "compilerOptions": {
    "typeRoots": [
      "./node_modules/@types",
      "./types"
    ]
  },
  "include": [
    "src",
    "types"
  ]
}
```

## 场景一：为 ES Module 库声明类型
假设 `my-lib` 提供如下 JS：

```javascript
// my-lib.js
export function add(a, b) { return a + b; }
export default function greet(name) { return `Hello, ${name}` }
```

在 `types/my-lib/index.d.ts` 中声明：

```typescript
declare module 'my-lib' {
  export function add(a: number, b: number): number;
  export default function greet(name: string): string;
}
```

在 TS 中使用：

```typescript
import greet, { add } from 'my-lib';
const msg = greet('Alice');
const sum = add(1, 2);
```

## 场景二：为 CommonJS 库声明类型
若库使用 `module.exports = fn`：

```javascript
// cjs-lib.js
module.exports = function sum(a, b) { return a + b }
```

声明文件：

```typescript
declare module 'cjs-lib' {
  function sum(a: number, b: number): number;
  export = sum;
}
```

使用方式：

```typescript
import sum = require('cjs-lib');
sum(1, 2);
```

> 若项目启用了 `esModuleInterop: true`，也可以 `import sum from 'cjs-lib'`。

## 场景三：声明全局变量与类型
为浏览器环境添加自定义全局：

```typescript
// types/globals.d.ts
declare global {
  interface Window {
    appVersion: string;
  }
}
export {} // 确保这是一个模块，使声明生效
```

在代码中：

```typescript
window.appVersion = '1.0.0';
```

## 场景四：模块增强（为已有库补充类型）
为 `express` 的 `Request` 添加 `user` 字段：

```typescript
// types/express-augment.d.ts
import 'express';

declare module 'express-serve-static-core' {
  interface Request {
    user?: { id: number; name: string };
  }
}
```

## 场景五：命名空间与复杂结构
某些库以全局对象暴露 API，可用命名空间描述：

```typescript
// types/my-namespace.d.ts
declare namespace MySDK {
  interface Config { endpoint: string }
  function init(config: Config): void
}
```

## 进阶：函数重载、泛型与联合类型

```typescript
declare module 'calc' {
  function parse(input: string): number
  function parse(input: number): number

  function wrap<T>(value: T): { value: T }

  type ID = string | number
}
```

## 如何验证声明是否正确
- 新建一个简短的 `.ts` 测试文件，导入并调用声明的 API。
- 运行类型检查（不生成代码）：

```bash
tsc --noEmit
```

- 编辑器会显示参数类型、返回类型；若报错，说明声明与使用不匹配。

## 常见坑位与排错
- 模块名不一致：`declare module 'xxx'` 的字符串必须与 `import 'xxx'` 完全一致。
- 忘记 `export`：在模块声明内未导出，外部不可见。
- 覆盖 vs 增强：增强已有类型时，用模块增强而不是重复声明模块。
- 路径与包含：确保 `types/` 被 `tsconfig.json` 的 `typeRoots/include` 覆盖到。
- 逐步完善：先声明最常用的 API，运行起来后再补充细节。

## 可选替代：用 JSDoc 给 JS 代码加类型
不写 `.d.ts`，直接在 JS 里用 JSDoc：

```javascript
/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
export function add(a, b) { return a + b }
```

在 `tsconfig.json` 中开启 `checkJs: true` 后，TypeScript 会基于注释进行类型检查。

掌握以上模式，你就能为任何库或全局环境逐步补齐类型，让项目在类型安全与开发体验上都有显著提升。