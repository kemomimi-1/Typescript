# 泛型约束多个泛型变量的情况下

在 TypeScript 中，泛型允许我们创建可重用的组件，但有时需要对泛型参数施加约束，以确保类型安全。当函数、类或接口涉及多个泛型参数时，我们可以为每个参数独立添加约束，使用 `extends` 关键字来指定类型必须满足的条件。这有助于防止无效的使用，并提供更好的类型推断。

## 为什么需要多个泛型约束？
- **类型安全**：约束确保传入的参数符合预期结构，避免运行时错误。
- **代码重用**：允许函数处理多种类型，同时保持严格的类型检查。
- **更好的 IDE 支持**：约束有助于自动补全和错误提示。

## 基本示例：合并对象
以下是一个经典的合并函数示例，其中两个泛型参数 T 和 U 都被约束为 object 类型，以确保它们可以安全地使用对象展开运算符。

```typescript
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const person = merge({ name: 'Alice' }, { age: 30, city: 'Wonderland' });
// person 的类型为 { name: string } & { age: number; city: string }
console.log(person); // { name: 'Alice', age: 30, city: 'Wonderland' }
```

在这个例子中：
- T 约束为 object，确保 obj1 是一个对象。
- U 约束为 object，确保 obj2 是一个对象。
- 返回类型 T & U 是交叉类型，结合了两者的属性。

## 高级示例：结合接口约束
你可以为泛型参数添加更具体的约束，例如继承自接口。

```typescript
interface Lengthwise {
  length: number;
}

interface Valuable {
  value: string;
}

function combine<T extends Lengthwise, U extends Valuable>(item1: T, item2: U): { length: number; value: string } {
  return { length: item1.length, value: item2.value };
}

const result = combine([1, 2, 3], { value: 'hello' }); // 有效，因为数组有 length 属性
// result: { length: 3, value: 'hello' }

// const invalid = combine(123, { value: 'test' }); // 错误：number 没有 length 属性
```

这里：
- T 必须实现 Lengthwise 接口（有 length 属性）。
- U 必须实现 Valuable 接口（有 value 属性）。

## 结合多个约束
一个泛型参数可以有多个约束，使用 & 运算符。

```typescript
function process<T extends Lengthwise & Valuable>(item: T): string {
  return `Length: ${item.length}, Value: ${item.value}`;
}

// 假设有一个类型符合两个接口
interface Item extends Lengthwise, Valuable {}
const item: Item = { length: 5, value: 'test' };
console.log(process(item)); // Length: 5, Value: test
```

## 注意事项
- **约束的顺序**：约束不影响顺序，但应根据逻辑选择合适的基类型。
- **默认类型**：在 TypeScript 2.3+ 中，可以为泛型参数提供默认类型，如 `T extends object = {}`。
- **潜在问题**：如果约束太严格，可能限制函数的灵活性；如果太松散，可能导致类型不安全。
- **与条件类型结合**：在更高级的场景中，可以将约束与条件类型一起使用，以动态调整返回类型。
- **性能考虑**：过多约束可能影响类型检查的性能，但通常在小型项目中不成问题。

通过这些约束，你可以构建更健壮的泛型代码。如果你在实际项目中遇到特定场景，我可以提供更多定制示例！