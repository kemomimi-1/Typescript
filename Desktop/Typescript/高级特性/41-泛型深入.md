# 泛型深入

## 概念定义

**泛型** 是 TypeScript 中创建可复用、类型安全的组件的重要特性。它允许我们在定义函数、接口或类时不指定具体类型，而是在使用时指定类型。

## 语法示例

### 泛型函数基础
```typescript
// 基本泛型函数
function identity<T>(arg: T): T {
  return arg;
}

// 使用类型参数
const result1 = identity<string>("Hello"); // 显式指定类型
const result2 = identity(42); // 类型推断
```

### 泛型约束
```typescript
interface Lengthwise {
  length: number;
}

// 泛型约束：T 必须具有 length 属性
function logLength<T extends Lengthwise>(arg: T): void {
  console.log(arg.length);
}

logLength("hello"); // ✅ 5
logLength([1, 2, 3]); // ✅ 3
// logLength(42); // ❌ 错误：number 没有 length 属性
```

### 多泛型参数
```typescript
// 多个类型参数
function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3];
const strings = map(numbers, n => n.toString()); // string[]
```

## 使用场景说明

1. **通用工具函数**：创建可处理多种类型的实用函数
2. **数据转换**：在不同数据类型之间进行转换操作
3. **集合操作**：处理数组、集合等数据结构的通用操作
4. **API 封装**：创建类型安全的 API 客户端
5. **组件开发**：开发可复用的 React/Vue 组件

## 注意事项

1. **类型参数命名**：通常使用单个大写字母（T, U, V, K 等）
2. **约束使用**：使用 `extends` 关键字添加约束条件
3. **默认类型**：可以为泛型参数提供默认类型
4. **类型推断**：充分利用 TypeScript 的类型推断能力
5. **复杂性控制**：避免过度复杂的泛型嵌套

## 相关代码示例

参见：[examples/41-generics-deep.ts](../examples/41-generics-deep.ts)

## 最佳实践

1. **明确的类型参数**：在复杂场景下显式指定类型参数
2. **适当的约束**：使用约束确保类型安全，但不要过度约束
3. **文档注释**：为复杂的泛型添加详细的文档注释
4. **测试覆盖**：为泛型代码编写全面的类型测试

---

**最后更新时间**：2025-11-21  
**相关主题**：[泛型](./27-泛型.md) | [接口](../类型系统/15-接口.md) | [类型约束](#)