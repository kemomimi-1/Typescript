# 模板字面量类型 (Template Literal Types)

## 概念定义
模板字面量类型是 TypeScript 4.1 引入的特性，它允许基于字符串字面量类型创建新的字符串字面量类型，支持字符串拼接、模式匹配等操作。

## 语法示例
```typescript
// 基本模板字面量类型
type Greeting = `Hello, ${string}!`;
type EventName = `${string}Changed`;

// 使用字面量类型
type Color = "red" | "blue" | "green";
type Size = "small" | "medium" | "large";
type ButtonClass = `btn-${Color}-${Size}`;

// 等效于:
// type ButtonClass = 
//   "btn-red-small" | "btn-red-medium" | "btn-red-large" |
//   "btn-blue-small" | "btn-blue-medium" | "btn-blue-large" |
//   "btn-green-small" | "btn-green-medium" | "btn-green-large";
```

## 基本用法

### 1. 字符串拼接
```typescript
// 基本字符串拼接
type FirstName = "Alice" | "Bob";
type LastName = "Smith" | "Johnson";
type FullName = `${FirstName} ${LastName}`;

// 等效于:
// type FullName = 
//   "Alice Smith" | "Alice Johnson" | 
//   "Bob Smith" | "Bob Johnson";

// 复杂拼接
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type ApiEndpoint = `/api/${string}`;
type ApiRoute = `${HttpMethod} ${ApiEndpoint}`;

// 等效于:
// type ApiRoute = 
//   "GET /api/users" | "GET /api/posts" | ... |
//   "POST /api/users" | "POST /api/posts" | ... |
//   "PUT /api/users" | "PUT /api/posts" | ... |
//   "DELETE /api/users" | "DELETE /api/posts" | ...
```

### 2. CSS 类名生成
```typescript
// CSS 类名模式
type Color = "primary" | "secondary" | "success" | "danger";
type Variant = "solid" | "outline" | "ghost";
type Size = "sm" | "md" | "lg";

type ButtonClass = `btn-${Color}-${Variant}-${Size}`;

type IconClass = `icon-${Color}-${Size}`;
type BadgeClass = `badge-${Variant}-${Color}`;

// 使用示例
function getButtonClass(color: Color, variant: Variant, size: Size): ButtonClass {
  return `btn-${color}-${variant}-${size}` as ButtonClass;
}

const btn = getButtonClass("primary", "solid", "md"); // "btn-primary-solid-md"
```

### 3. 事件处理
```typescript
// 事件处理器名称
type EventType = "click" | "hover" | "focus" | "blur";
type HandlerName = `on${Capitalize<EventType>}`;

// 等效于:
// type HandlerName = "onClick" | "onHover" | "onFocus" | "onBlur";

// 使用示例
interface EventHandlers {
  [K in HandlerName]: () => void;
}

const handlers: EventHandlers = {
  onClick: () => console.log("clicked"),
  onHover: () => console.log("hovered"),
  onFocus: () => console.log("focused"),
  onBlur: () => console.log("blurred")
};
```

## 字符串操作工具

### 1. Uppercase
```typescript
// 转换为大写
type Uppercase<S extends string> = intrinsic;

type Method = "get" | "post" | "put" | "delete";
type UpperMethod = Uppercase<Method>; // "GET" | "POST" | "PUT" | "DELETE"

type Event = "click" | "submit";
type UpperEvent = Uppercase<Event>; // "CLICK" | "SUBMIT"
```

### 2. Lowercase
```typescript
// 转换为小写
type Lowercase<S extends string> = intrinsic;

type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type LowerMethod = Lowercase<HttpMethod>; // "get" | "post" | "put" | "delete"

type Action = "CREATE" | "UPDATE" | "DELETE";
type LowerAction = Lowercase<Action>; // "create" | "update" | "delete"
```

### 3. Capitalize
```typescript
// 首字母大写
type Capitalize<S extends string> = intrinsic;

type Event = "click" | "hover" | "focus";
type Handler = `on${Capitalize<Event>}`; // "onClick" | "onHover" | "onFocus"

type Status = "pending" | "success" | "error";
type CapitalStatus = Capitalize<Status>; // "Pending" | "Success" | "Error"
```

### 4. Uncapitalize
```typescript
// 首字母小写
type Uncapitalize<S extends string> = intrinsic;

type Component = "Button" | "Input" | "Modal";
type Instance = Uncapitalize<Component>; // "button" | "input" | "modal"

type HttpMethod = "GET" | "POST";
type MethodVar = Uncapitalize<Lowercase<HttpMethod>>; // "get" | "post"
```

## 模式匹配

### 1. infer 模式匹配
```typescript
// 提取模板中的部分
type ExtractColor<S> = S extends `btn-${infer Color}-${string}` ? Color : never;
type ExtractSize<S> = S extends `btn-${string}-${infer Size}` ? Size : never;

// 使用示例
type Button = "btn-primary-sm" | "btn-secondary-md" | "btn-success-lg";
type Colors = ExtractColor<Button>; // "primary" | "secondary" | "success"
type Sizes = ExtractSize<Button>; // "sm" | "md" | "lg"
```

### 2. 路径参数提取
```typescript
// 提取 REST API 路径参数
type ExtractParams<Path> = 
  Path extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractParams<Rest>
    : Path extends `${string}:${infer Param}`
      ? Param
      : never;

// 使用示例
type UserPath = "/users/:userId/posts/:postId";
type Params = ExtractParams<UserPath>; // "userId" | "postId"

type ProductPath = "/products/:category/:id";
type ProductParams = ExtractParams<ProductPath>; // "category" | "id"
```

### 3. 验证格式
```typescript
// 验证字符串格式
type IsValidEmail<S> = 
  S extends `${infer Local}@${infer Domain}.${string}` ?
    Local extends string ?
      Domain extends string ?
        true : false : false : false;

// 使用示例
type Test1 = IsValidEmail<"alice@example.com">; // true
type Test2 = IsValidEmail<"invalid-email">; // false

type IsHexColor<S> = S extends `#${string}` ? true : false;
type Test3 = IsHexColor<"#ff0000">; // true
type Test4 = IsHexColor<"red">; // false
```

## 高级应用

### 1. 国际化键生成
```typescript
// 生成国际化键
type Locale = "en" | "zh" | "ja";
type Namespace = "common" | "auth" | "dashboard";
type Key = "title" | "description" | "button";

type I18nKey = `${Locale}:${Namespace}.${Key}`;

// 等效于:
// type I18nKey = 
//   "en:common.title" | "en:common.description" | "en:common.button" |
//   "en:auth.title" | "en:auth.description" | "en:auth.button" |
//   "en:dashboard.title" | "en:dashboard.description" | "en:dashboard.button" |
//   "zh:common.title" | "zh:common.description" | "zh:common.button" | ...

// 使用示例
function translate(key: I18nKey): string {
  // 翻译逻辑
  return "translated text";
}

translate("en:common.title"); // 有效
translate("zh:auth.button"); // 有效
// translate("fr:common.title"); // 错误: "fr" 不是有效的 Locale
```

### 2. CSS 变量生成
```typescript
// CSS 自定义属性
type ColorScale = "50" | "100" | "200" | "300" | "400" | "500" | 
                 "600" | "700" | "800" | "900" | "950";
type ColorName = "primary" | "secondary" | "accent" | "neutral";

type CssVariable = `--${ColorName}-${ColorScale}`;

type CssColorValue = `var(${CssVariable})`;

// 使用示例
const styles = {
  '--primary-500': '#3b82f6',
  '--primary-600': '#2563eb',
  '--secondary-500': '#a855f7',
} as const;

function getColor(color: ColorName, scale: ColorScale): string {
  const varName = `--${color}-${scale}` as CssVariable;
  return `var(${varName})`;
}

const primaryColor = getColor("primary", "500"); // "var(--primary-500)"
```

### 3. 路由类型安全
```typescript
// 类型安全的路由
type Route = 
  | `/`
  | `/about`
  | `/users`
  | `/users/${number}`
  | `/posts`
  | `/posts/${string}`
  | `/search?q=${string}`
  | `/settings/${"profile" | "account" | "privacy"}`;

// 路由生成函数
function createRoute(path: Route): string {
  return path;
}

// 使用示例
createRoute("/"); // 有效
createRoute("/users/123"); // 有效
createRoute("/posts/hello-world"); // 有效
createRoute("/search?q=typescript"); // 有效
createRoute("/settings/profile"); // 有效
// createRoute(/users/abc"); // 错误: "abc" 不是 number
// createRoute(/invalid"); // 错误: 不是有效的 Route
```

## 实用模式

### 1. 动态类名生成
```typescript
// 响应式类名
type Breakpoint = "sm" | "md" | "lg" | "xl" | "2xl";
type Property = "display" | "padding" | "margin" | "text";
type Value = "block" | "hidden" | "flex" | "inline" | "inline-block";

type ResponsiveClass = `${Property}-${Breakpoint}-${Value}`;

// 使用示例
const classes: ResponsiveClass[] = [
  "display-md-block",
  "padding-lg-10",
  "text-xl-center"
];

function getResponsiveClass(
  property: Property, 
  breakpoint: Breakpoint, 
  value: Value
): ResponsiveClass {
  return `${property}-${breakpoint}-${value}` as ResponsiveClass;
}
```

### 2. 枚举值生成
```typescript
// 从枚举生成字符串类型
type EnumToString<T extends Record<string, string | number>> = {
  [K in keyof T]: `${T[K]}`;
}[keyof T];

// 使用示例
enum HttpStatus {
  OK = 200,
  Created = 201,
  BadRequest = 400,
  NotFound = 404,
  InternalError = 500
}

type StatusString = EnumToString<HttpStatus>;
// 等效于: "200" | "201" | "400" | "404" | "500"

enum Direction {
  North = "N",
  South = "S", 
  East = "E",
  West = "W"
}

type DirectionString = EnumToString<Direction>;
// 等效于: "N" | "S" | "E" | "W"
```

### 3. 错误代码生成
```typescript
// 类型安全的错误代码
type Module = "auth" | "user" | "payment" | "notification";
type ErrorType = "validation" | "not_found" | "permission" | "internal";
type ErrorCode = `${Module}.${ErrorType}.${string}`;

// 使用示例
function createError(module: Module, type: ErrorType, code: string): ErrorCode {
  return `${module}.${type}.${code}` as ErrorCode;
}

const errors = {
  invalidEmail: createError("auth", "validation", "invalid_email"),
  userNotFound: createError("user", "not_found", "user_not_found"),
  paymentFailed: createError("payment", "internal", "payment_failed")
};

function handleError(code: ErrorCode) {
  // 类型安全的错误处理
  switch (code) {
    case "auth.validation.invalid_email":
      return "Invalid email address";
    case "user.not_found.user_not_found":
      return "User not found";
    // ...
  }
}
```

## 最佳实践

### 1. 性能考虑
```typescript
// 避免过度复杂的模板类型
type OverlyComplex = `${"a" | "b" | "c"}${"1" | "2" | "3"}${"x" | "y" | "z"}`;
// 生成 3 × 3 × 3 = 27 种组合

// 对于大型联合类型，考虑使用更具体的基础类型
type SimpleBase = string; // 而不是巨大的联合类型

// 使用类型别名提高可读性
type ButtonVariant = `btn-${Color}-${Size}`;
```

### 2. 可维护性
```typescript
// 使用描述性的类型别名
type BillingPeriod = "monthly" | "yearly" | "lifetime";
type PlanName = "basic" | "pro" | "enterprise";
type SubscriptionKey = `sub_${PlanName}_${BillingPeriod}`;

// 比直接使用字符串字面量更易维护
type OldStyle = "sub_basic_monthly" | "sub_basic_yearly" | "sub_basic_lifetime" |
                "sub_pro_monthly" | "sub_pro_yearly" | "sub_pro_lifetime" |
                "sub_enterprise_monthly" | "sub_enterprise_yearly" | "sub_enterprise_lifetime";
```

### 3. 错误处理
```typescript
// 为模板类型提供合理的错误信息
type ValidateEmail<S> = 
  S extends `${infer Local}@${infer Domain}.${string}` ?
    Local extends string ?
      Domain extends string ?
        S : `Invalid email: ${S}` : `Invalid email: ${S}` : `Invalid email: ${S}`;

// 使用示例
type Test1 = ValidateEmail<"alice@example.com">; // "alice@example.com"
type Test2 = ValidateEmail<"invalid">; // "Invalid email: invalid"
```

## 常见错误

### 1. 过度使用
```typescript
// 不要为所有字符串都创建模板类型
// 不良实践
type EveryString = `${string}`; // 等同于 string

// 良好实践 - 只在需要约束时使用
type SpecificPattern = `user_${number}`; // 有意义的约束
```

### 2. 性能问题
```typescript
// 避免创建巨大的联合类型
type HugeUnion = 
  `${"a" | "b" | "c" | "d" | "e"}${"1" | "2" | "3" | "4" | "5"}${"x" | "y" | "z"}`;
// 生成 5 × 5 × 3 = 75 种组合

// 考虑使用运行时验证而不是类型检查
function validatePattern(input: string): boolean {
  return /^[a-e][1-5][xyz]$/.test(input);
}
```

### 3. 复杂的模式匹配
```typescript
// 避免过于复杂的模式匹配
type TooComplex<S> = 
  S extends `btn-${infer Color}-${infer Size}` ?
    Color extends "primary" | "secondary" ?
      Size extends "sm" | "md" | "lg" ?
        S : never : never : never;

// 简化版本
type SimpleColor = "primary" | "secondary";
type SimpleSize = "sm" | "md" | "lg";
type SimpleButton = `btn-${SimpleColor}-${SimpleSize}`;
```

## 总结
模板字面量类型提供了强大的字符串类型操作能力：

✅ **优点**:
- 类型安全的字符串拼接
- 模式匹配和提取
- 编译时字符串验证
- 减少重复代码

❌ **缺点**:
- 可能创建巨大的联合类型
- 复杂模式可能难以理解
- 某些情况下可能影响编译性能

**最佳实践**:
- 只在需要约束时使用
- 使用类型别名提高可读性
- 注意性能影响
- 为复杂模式添加文档
- 结合运行时验证使用

---
**示例文件**: [examples/30-template-literal-types.ts](../examples/30-template-literal-types.ts)