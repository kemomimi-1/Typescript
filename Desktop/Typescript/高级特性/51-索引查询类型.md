# 索引查询类型

索引查询类型使用 `keyof` 操作符来获取一个类型的公有属性键的联合类型。这是一个强大的工具，用于动态处理类型键，常与映射类型或条件类型结合使用。

## 为什么使用索引查询？
- **动态键**：在编译时获取键集合，用于泛型编程。
- **类型安全**：确保只使用有效的键，避免拼写错误。
- **与索引访问结合**：查询键后，可以访问对应值的类型。

## 基本示例：keyof
```typescript
type Person = {
  name: string;
  age: number;
  city: string;
};

type PersonKeys = keyof Person; // 'name' | 'age' | 'city'

function getProperty(obj: Person, key: PersonKeys) {
  return obj[key];
}

const name = getProperty({ name: 'Alice', age: 30, city: 'Wonderland' }, 'name'); // string
// getProperty(..., 'invalid'); // 错误：'invalid' 不是 PersonKeys
```

## 索引访问类型
使用 `T[K]` 语法访问键 K 的类型（K 必须是 keyof T 的子类型）。

```typescript
type NameType = Person['name']; // string
type AgeType = Person['age']; // number

// 动态访问
type PropType<K extends keyof Person> = Person[K];
type CityType = PropType<'city'>; // string
```

## 与联合类型结合
keyof 可以处理联合类型，返回所有键的联合。

```typescript
type A = { x: number; y: number };
type B = { y: string; z: boolean };
type Union = A | B;
type UnionKeys = keyof Union; // 'y' （只有共同键）
```

注意：对于联合类型，keyof 返回交集键（共同键）。

## 高级用法：泛型函数
创建一个通用的 setter 函数。

```typescript
function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {
  obj[key] = value;
}

const person: Person = { name: 'Alice', age: 30, city: 'Wonderland' };
setProperty(person, 'age', 31); // 有效
// setProperty(person, 'age', 'thirty'); // 错误：string 不符合 number
```

## 注意事项
- **私有/保护键**：keyof 只包括公有键。
- **字符串字面量**：键是字符串字面量类型，不是 string。
- **性能**：在复杂类型中，keyof 可能增加类型检查时间。
- **常见错误**：对非对象类型使用 keyof 返回 never。
- **与映射类型**：常用于 `{ [P in keyof T]: ... }` 创建新类型。
- **版本**：在 TypeScript 2.1+ 中支持字符串/数字键。

索引查询是类型体操的核心，能创建高度动态的类型。如果您有特定查询示例的需求，请告诉我！