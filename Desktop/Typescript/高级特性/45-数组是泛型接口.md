# 数组是泛型接口

在 TypeScript 中，数组不是一种特殊的内置类型，而是基于泛型接口 `Array<T>` 实现的。这意味着数组可以处理任何元素类型 T，并提供类型安全的操作。`string[]` 语法实际上是 `Array<string>` 的简写形式。这种设计使得数组高度灵活，并与 TypeScript 的类型系统无缝集成。

## 为什么数组是泛型接口？
- **类型安全**：确保数组元素符合指定类型，防止类型错误。
- **重用性**：同一个 Array 接口可以用于数字、字符串、对象等。
- **内置方法支持**：数组方法如 map、filter 会自动推断和保留类型。

## 基本示例
声明和使用泛型数组。

```typescript
// 使用 Array<T> 语法
const numbers: Array<number> = [1, 2, 3];
numbers.push(4); // 有效
// numbers.push('five'); // 错误：不能推 string 到 number

// 使用简写语法
const strings: string[] = ['a', 'b', 'c'];
const mixed: (string | number)[] = ['hello', 42];
```

## 只读数组
TypeScript 提供 `ReadonlyArray<T>` 来防止修改。

```typescript
const readOnlyNumbers: ReadonlyArray<number> = [1, 2, 3];
// readOnlyNumbers.push(4); // 错误：ReadonlyArray 没有 push 方法

// 转换为可变数组
const mutable = [...readOnlyNumbers];
mutable.push(4);
```

## 数组方法与类型推断
数组的内置方法会智能地处理类型。

```typescript
const evens = numbers.filter(n => n % 2 === 0); // evens: number[]

const doubled = numbers.map(n => n * 2); // doubled: number[]

const found = numbers.find(n => n > 2); // found: number | undefined
```

## 元组 vs 数组
元组是固定长度的数组变体，也基于泛型。

```typescript
const tuple: [string, number] = ['age', 30];
// tuple[0] 是 string, tuple[1] 是 number
// tuple.push('extra'); // 有效，但会丢失类型安全（使用 strict 模式可避免）
```

## 注意事项
- **性能**：大型数组操作可能影响性能，但 TypeScript 不会改变运行时行为。
- **与 JavaScript 兼容**：TypeScript 数组编译后仍是标准 JS 数组。
- **常见错误**：在非严格模式下，数组可以推入不匹配类型；启用 `strictNullChecks` 以增强安全。
- **高级用法**：结合泛型函数处理数组，如 `function head<T>(arr: T[]): T | undefined { return arr[0]; }`。
- **只读 vs const**：`const arr = [1,2]` 防止重新赋值，但不防止修改；使用 ReadonlyArray 防止修改。

理解数组的泛型本质有助于编写更健壮的代码。如果您需要数组操作的特定示例，请告诉我！